<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JerryForge Viewer (Offline)</title>
  <style>
    :root { 
      --rightSidebarW: 370px;
            --leftSidebarW: 390px;
--timelineH: 260px;
      --toolbarH: 54px;
      --bg:#0b0f14; 
      --panel:#101720; 
      --text:#e7eef7; 
      --muted:#93a4b8; 
      --line:#233244; 
    }
    * { box-sizing:border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:var(--bg); color:var(--text); }
    header { padding:10px 14px; border-bottom:1px solid var(--line); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header .grow { flex:1 1 auto; min-width: 180px; }
    button, select, input[type="file"], input[type="number"] {
      background:var(--panel); color:var(--text); border:1px solid var(--line);
      padding:8px 10px; border-radius:10px; max-width:100%;
    }
    button { cursor:pointer; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .muted { color:var(--muted); font-size:12px; }
    body::-webkit-scrollbar {
      width: 0px;
      height: 0px;
    }
    /* Layout: content row + bottom timeline */
    .app {
      height: calc(100vh - 56px);
      display:flex;
      flex-direction:column;
      min-height: 0;
    }
    .row {
      flex: 1 1 auto;
      display:flex;
      min-height:0;
      overflow:hidden;
    }
    #canvasWrap { flex:1 1 auto; position:relative; overflow:hidden; min-width: 0; }
    canvas#c { width:100%; height:100%; display:block; }

    /* Sidebar: flexible width, wraps content, no horizontal scroll */
    #right {
      flex: 0 0 clamp(260px, 26vw, 420px);
      border-left:1px solid var(--line);
      background:rgba(16,23,32,.7);
      backdrop-filter: blur(6px);
      overflow: hidden;
      min-width: 40px;
      max-width: 500px;
    }

    #right * { min-width: 0; }
    #right .section { padding:12px 14px; border-bottom:1px solid var(--line); }
    .drop { border:1px dashed var(--line); border-radius:12px; padding:10px; }

    details { border: 1px solid var(--line); border-radius: 12px; overflow: hidden; background: rgba(16,23,32,.45); }
    details > summary {
      cursor: pointer;
      padding: 10px 12px;
      user-select: none;
      list-style: none;
      display:flex; align-items:center; justify-content:space-between;
      font-weight: 750;
      gap: 8px;
      flex-wrap: wrap;
    }
    details > summary::-webkit-details-marker { display:none; }
    .detailsBody { padding: 10px 12px; border-top:1px solid var(--line); }

    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--line); font-size:12px; color:var(--muted); white-space:nowrap; }
    .pill.level { border-color: transparent; color: #081018; font-weight: 800; }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .grid3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
@media (max-width: 980px) {
      #right { flex-basis: 320px; }
      .grid3 { grid-template-columns: 1fr 1fr; }
    }
    @media (max-width: 740px) {
      .row { flex-direction:column; }
      #right { flex: 0 0 auto; max-height: 44vh; border-left:none; border-top:1px solid var(--line); }
    }

    label { font-size:12px; color:var(--muted); display:block; margin-bottom:4px; }

    #watchList { max-height: 40vh; overflow:auto; border:1px solid var(--line); border-radius:10px; }
    .watchItem { padding:10px 10px; border-bottom:1px solid var(--line); cursor:pointer; overflow:hidden; }
    .watchItem:hover { background: rgba(255,255,255,.04); }
    .watchItem:last-child { border-bottom:none; }
    .watchItem.selected { outline: 2px solid rgba(255,255,255,0.35); outline-offset:-2px; background: rgba(255,255,255,.03); }
    .bigValue { font-size: 15px; font-weight: 800; margin-top: 6px; word-break: break-word; }

    .kvs { display:grid; grid-template-columns: 1fr auto; gap:6px 10px; font-size:13px; }
    .kvs div:nth-child(2n) { color:var(--muted); text-align:right; }

    /* Bottom timeline */
    #timelineBar {
      flex: 0 0 96px;
      border-top:1px solid var(--line);
      background: rgba(8,12,18,0.95);
      display:flex;
      flex-direction:column;
      padding: 10px 12px;
      gap: 8px;
    }
    #timelineTop {
      display:grid;
      grid-template-columns:300px 1fr;
      align-items:center;
      column-gap:10px;
      row-gap:8px;
    }
    #timelineLeft { display:flex; align-items:center; gap:10px; }
    #timelineCanvas {
      width:100%;
      height: 54px;
      border:1px solid var(--line);
      border-radius: 12px;
      background: rgba(16,23,32,0.55);
      display:block;
    }
    #timelineHint { color: var(--muted); font-size: 12px; }

  header.toolbar{
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    align-items: center;
    flex-wrap: nowrap;
    width: 250px; 
    display:flex;
    align-items:center;
    gap:10px;
    padding:10px 12px;
    border-bottom:1px solid rgba(255,255,255,0.08);
    background: linear-gradient(180deg, rgba(8,14,22,0.92), rgba(8,14,22,0.80));
    position: sticky;
    top: 0;
    z-index: 50;
    height: var(--toolbarH);
    box-sizing: border-box;
  }
  .iconBtn{
    height: 34px;
    min-width: 38px;
    padding: 0 10px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.04);
    color: #e9eef7;
    font-size: 16px;
    cursor: pointer;
    transition: transform 0.3s ease;
  }
  .iconBtn:disabled{ opacity:0.4; cursor:not-allowed; }

  .iconBtn:hover:not(:disabled) {
    background: rgba(255,255,255,0.08);
    border-color: rgba(255,255,255,0.20);
    transform: scale(1.05);
  }

  .chip{
    display:flex;
    align-items:center;
    justify-content:center;  
    gap:8px;
    padding:6px 10px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.03);
    height: 34px;
    box-sizing: border-box;
  }

  .chip select{
    background: rgba(0,0,0,0.25);
    border: 1px solid rgba(255,255,255,0.12);
    color: var(--muted);
    border-radius: 10px;
    padding: 4px 8px;
    height: 24px;
    transition:cubic-bezier(0.25, 0.46, 0.45, 0.94) 10s ease;
  }

  .chip:hover:not(:disabled) select{
    color: var(--text);
    transform: scale(1.02);
  }
  
  .rowline{ display:flex; align-items:center; gap:10px; }
  .divider{ height:1px; background: rgba(255,255,255,0.10); }

  /* App layout with resizable sidebar + resizable timeline */
  .app{
    height: calc(100vh - var(--toolbarH));
    display: grid;
    grid-template-rows: 1fr 8px var(--timelineH);
    overflow: hidden;
  }
  .row{
    display: grid;
    grid-template-columns: var(--leftSidebarW) 8px 1fr 8px var(--rightSidebarW);
    overflow: hidden;
    min-height: 0;
  }
  /* lock grid items to columns so hiding/collapsing one panel doesn't reflow everything */
  #left{ grid-column: 1; }
  #vSplitL{ grid-column: 2; }
  #canvasWrap{ grid-column: 3; min-width: 100px; min-height: 100px; }
  #vSplit{ grid-column: 4; }
  #right{ grid-column: 5; min-width: 240px; overflow:auto; }

  /* when left is collapsed, keep the splitter at the edge */
  .row.leftCollapsed{
    grid-template-columns: 0px 8px 1fr 8px var(--rightSidebarW);
  }

  #canvasWrap{ min-width:100; min-height:100; }
  #right{ min-width: 240px; overflow:auto; }

  #left{ min-width: 220px; overflow:auto; }
  #left.isCollapsed { display:none !important; }

  .splitterV{
    cursor: col-resize;
    background: rgba(255,255,255,0.06);
    border-left: 1px solid rgba(255,255,255,0.08);
    border-right: 1px solid rgba(255,255,255,0.08);
  }
  .splitterV:hover{ background: rgba(255,255,255,0.10); }
  .splitterH{
    cursor: row-resize;
    background: rgba(255,255,255,0.06);
    border-top: 1px solid rgba(255,255,255,0.08);
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }
  .splitterH:hover{ background: rgba(255,255,255,0.10); }

  /* Timeline bar should never clip its contents */
  #timelineBar{
    height: var(--timelineH);
    min-height: 140px;
    max-height: 400px;
    overflow: hidden;
    display:flex;
    flex-direction:column;
  }
  #timelineCanvas{ flex: 1 1 auto; min-height: 0; }
  #timelineHint{ padding-bottom: 8px; max-height: 25px;}
  /* --- Collapsible panels: when fully dragged closed, only handle remains --- */
  #right.isCollapsed { display:none !important; }
  #timelineBar.isCollapsed { display:none !important; }

  /* Keep splitters visible even when panels are collapsed */
  .splitterV, .splitterH {
    position: relative;
    user-select: none;
    touch-action: none;
  }
  .splitterV::after {
    content: "‚ãÆ";
    position:absolute;
    left:50%; top:50%;
    transform: translate(-50%,-50%);
    color: rgba(255,255,255,0.55);
    font-size: 14px;
    pointer-events:none;
  }
  .splitterH::after {
    content: "‚ãØ";
    position:absolute;
    left:50%; top:50%;
    transform: translate(-50%,-50%);
    color: rgba(255,255,255,0.55);
    font-size: 16px;
    pointer-events:none;
  }

  /* Pose list items */
  .poseItem { padding:8px 10px; border-bottom:1px solid var(--line); cursor:pointer; }
  .poseItem:hover { background: rgba(255,255,255,.04); }
  .poseItem:last-child { border-bottom:none; }
  .poseItem.selected { outline: 2px solid rgba(255,255,255,0.35); outline-offset:-2px; background: rgba(255,255,255,.03); }

  /* === Help modal === */
  .modal { position:fixed; inset:0; z-index:80; }
  .modalBackdrop { position:absolute; inset:0; background:rgba(0,0,0,0.55); }
  .modalCard { position:relative; width:min(720px, calc(100vw - 28px)); max-height:calc(100vh - 28px);
               margin:14px auto; background:var(--panel); border:1px solid var(--line);
               border-radius:14px; overflow:hidden; box-shadow:0 12px 40px rgba(0,0,0,0.45); }
  .modalHeader { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; border-bottom:1px solid var(--line); }
  .modalBody { padding:12px; overflow:auto; color:var(--text); }
  .modalBody a { color:#9fd1ff; text-decoration:none; }
  .modalBody a:hover { text-decoration:underline; }

  /* === Watch click popup (tiny) === */
  #watchPopup { position:fixed; z-index:90; background:rgba(16,23,32,0.98);
                border:1px solid var(--line); border-radius:10px; padding:8px 10px;
                font-size:12px; line-height:1.25; max-width:340px;
                box-shadow:0 10px 24px rgba(0,0,0,0.40);   pointer-events:none; }
  #watchPopup .row { display:flex; gap:8px; }
  #watchPopup .k { color:var(--muted); min-width:54px; }
  #watchPopup .v { color:var(--text); word-break:break-word; }

   /* tighten pose list */
  .poseItem .sub { margin-top:3px; font-size:12px; color:var(--muted); }

  /* Floating Info Window */
  #floatingInfo {
    position: fixed;
    top: 80px;
    left: 20px;
    width: 80px;
    min-width: 222px;
    min-height: 61px;
    max-width: 300px;
    max-height: 450px;
    background: rgba(16, 23, 32, 0.85);
    backdrop-filter: blur(12px);
    border: 1px solid var(--line);
    border-radius: 12px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    overflow: hidden;
  }

  #floatHeader {
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.05);
    border-bottom: 1px solid var(--line);
    cursor: grab;
    display: flex;
    justify-content: space-between;
    align-items: center;
    user-select: none;
  }

  #floatHeader:active { cursor: grabbing; }

  #floatBody {
    padding: 12px;
    font-size: 14px;
    flex: 1;
    overflow-y: auto;
  }

.hidden { display: none !important; }

/* Floating window container */
#floatingInfo {
  --float-bg: rgba(18, 18, 20, 0.60);
  --float-border: rgba(255, 255, 255, 0.12);
  --float-line: rgba(255, 255, 255, 0.10);
  --float-text: rgba(255, 255, 255, 0.92);
  --float-muted: rgba(255, 255, 255, 0.60);
  --float-soft: rgba(255, 255, 255, 0.80);
  --float-accent: rgba(110, 168, 255, 1);
  --float-accent-bg: rgba(110, 168, 255, 0.14);

  position: absolute;
  right: 16px;
  top: 16px;
  width: 280px;
  max-width: min(320px, calc(100vw - 32px));
  min-width: 222;
  color: var(--float-text);
  background: var(--float-bg);
  border: 1px solid var(--float-border);
  border-radius: 14px;
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.55);
  backdrop-filter: blur(15px);
  -webkit-backdrop-filter: blur(10px);
  overflow: hidden;

  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  font-size: 12.5px;
  line-height: 1.35;
}

/* Header */
#floatHeader {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  padding: 10px 10px 10px 12px;
  border-bottom: 1px solid var(--float-line);
  background: rgba(255, 255, 255, 0.03);
}

.float-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
}

.float-title-text {
  font-weight: 650;
  font-size: 13px;
  letter-spacing: 0.2px;
}

.float-subtitle {
  color: var(--float-muted);
  font-size: 11.5px;
  white-space: nowrap;
}

/* Close button */
#btnCloseFloat.iconBtn {
  width: 28px;
  height: 28px;
  border-radius: 10px;
  border: 1px solid var(--float-line);
  background: rgba(255, 255, 255, 0.03);
  color: var(--float-muted);
  cursor: pointer;
  display: grid;
  place-items: center;
  transition: background 120ms ease, border-color 120ms ease, color 120ms ease;
}

#btnCloseFloat.iconBtn:hover {
  background: rgba(255, 255, 255, 0.07);
  border-color: rgba(255, 255, 255, 0.16);
  color: var(--float-text);
}

#btnCloseFloat.iconBtn:active {
  transform: translateY(0.5px);
}

#btnCloseFloat.iconBtn:focus-visible {
  outline: 2px solid rgba(110, 168, 255, 0.7);
  outline-offset: 2px;
}

/* hidden by default */
#btnCloseFloat.iconBtn {
  opacity: 0;
  pointer-events: none;
  transition: opacity 160ms ease, background 120ms ease, border-color 120ms ease, color 120ms ease;
}

/* show when hovering the floating island (or focusing within it) */
#floatHeader:hover #btnCloseFloat.iconBtn,
#floatHeader:focus-within #btnCloseFloat.iconBtn {
  opacity: 1;
  pointer-events: auto;
}

.statsPanel{
  margin-top: 10px;
  padding: 10px 12px 12px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.03);
  border-radius: 12px;
  box-shadow: 0 10px 28px rgba(0,0,0,0.25);
}

.statsHeader{
  display:flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 8px;
}

.statsTitle{
  font-weight: 700;
  font-size: 16px;
  letter-spacing: 0.2px;
  color: rgba(255,255,255,0.92);
}

.statsHint{
  font-size: 10.5px;
  color: rgba(255,255,255,0.55);
}

.kvs{
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 6px 10px;
  font-size: 11px;
  font-variant-numeric: tabular-nums;
}

.kvs .kv.k{
  color: rgba(255,255,255,0.65);
  font-weight: 550;
}

.kvs .kv.v{
  color: rgba(255,255,255,0.92);
  font-weight: 650;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

.kvs .kv.k{
  position: relative;
  padding-top: 2px;
}
.kvs .kv.k:not(:first-child)::before{
  content:"";
  position:absolute;
  left:0; right:-10px; top:-4px;
  height:1px;
  background: rgba(255,255,255,0.06);
}

#floatingInfo::-webkit-scrollbar { width: 0; height: 0; }
#floatingInfo { scrollbar-width: none; -ms-overflow-style: none; }

/* Body */
#floatBody {
  padding: 10px 12px 12px 12px;
}

.float-section {
  display: grid;
  gap: 6px;
}

/* Rows */
.float-row {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  gap: 12px;
}

.float-row .k {
  color: var(--float-muted);
  font-weight: 550;
  letter-spacing: 0.15px;
}

.float-row .v {
  font-weight: 650;
  font-size: 12.25px;
  color: var(--float-text);
  font-variant-numeric: tabular-nums;
}

.float-row .v.v-soft {
  font-weight: 600;
  color: var(--float-soft);
}

/* Divider */
.divider {
  margin: 10px 0;
  height: 1px;
  background: var(--float-line);
}

/* Watch block */
.float-watch {
  margin-top: 2px;
  padding: 10px 10px;
  background: rgba(255, 255, 255, 0.035);
  border: 1px solid var(--float-line);
  border-radius: 12px;
}

.float-watch-head {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 8px;
}

.float-watch-time {
  color: var(--float-muted);
  font-size: 11.5px;
  white-space: nowrap;
}

/* Chip used for clickable watch label */
.chip {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px solid rgba(110, 168, 255, 0.35);
  background: var(--float-accent-bg);
  color: rgba(190, 215, 255, 0.98);
  font-size: 11.5px;
  font-weight: 650;
  letter-spacing: 0.15px;
  user-select: none;
}

/* Resizer handle */
#floatResizer {
  height: 12px;
  cursor: ns-resize;
  background:
    linear-gradient(to bottom, rgba(255,255,255,0.06), rgba(255,255,255,0.00));
  border-top: 1px solid var(--float-line);
}

  /* Resizer Handle */
  #floatResizer {
    position: absolute;
    right: 0; bottom: 0;
    width: 15px; height: 15px;
    cursor: nwse-resize;
    background: linear-gradient(135deg, transparent 50%, var(--muted) 50%);
    opacity: 0.3;
  }

  
    /* Left sidebar: fixed top bar + scrollable live window */
  #left{
    min-width: 220px;
    overflow: hidden;              /* prevent sideways scroll on the sidebar itself */
    border-right: 1px solid var(--line);
    background: rgba(16,23,32,.7);
    backdrop-filter: blur(6px);
    display: flex;
    flex-direction: column;
    min-height: 0;
  }
  #left *{ min-width: 0; }

  .leftTopBar{
    flex: 0 0 auto;
    padding: 12px 14px;
    border-bottom: 1px solid var(--line);
    /* keep visual stable while resizing */
  }

  /* keep controls pinned and sized */
  .leftTopRow{
    display: grid;
    grid-template-columns: auto auto 1fr auto;
    align-items: center;
    gap: 8px;
  }

  /* smaller pills for Stop/Connect */
  #left .pillAction{
    height: 28px;
    min-width: 64px;
    padding: 0 10px;
    border-radius: 12px;
    font-size: 13px;
    justify-content: center;
  }

  .leftRefreshChip{
    justify-self: end;
    display:flex;
    align-items:center;
    gap: 8px;
    padding: 6px 10px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.03);
    height: 34px;
    box-sizing: border-box;
    white-space: nowrap;
  }

  /* "Refresh" inside the dropdown chip */
  .leftRefreshBtn{
    height: 24px;
    padding: 0 10px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(0,0,0,0.25);
    color: var(--muted);
    font-size: 12px;
    cursor: pointer;
  }
  .leftRefreshBtn:hover{
    color: var(--text);
    border-color: rgba(255,255,255,0.20);
    background: rgba(255,255,255,0.06);
  }

  .leftRefreshChip select{
    width: 92px;                  /* fixed so it doesn't wiggle with resize */
    background: rgba(0,0,0,0.25);
    border: 1px solid rgba(255,255,255,0.12);
    color: var(--muted);
    border-radius: 10px;
    padding: 4px 8px;
    height: 24px;
  }
  .leftRefreshChip:hover select{ color: var(--text); }

  .leftBody{
    flex: 1 1 auto;
    min-height: 0;
    padding: 12px 14px;
    overflow: hidden;
  }

  #liveWin{
    width: 100%;
    height: 100%;
    min-height: 0;
    padding: 10px 12px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(0,0,0,0.18);
    color: #e9eef7;
    outline: none;
    resize: none;

    /* no sideways scroll + wrap long lines */
    overflow-y: auto;
    overflow-x: hidden;
    white-space: pre-wrap;
    overflow-wrap: anywhere;
    word-break: break-word;

    line-height: 1.35;
  }
  .monoText{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }

  .iconBtn.isOn{ border-color: rgba(120,220,160,0.55); box-shadow: 0 0 0 1px rgba(120,220,160,0.15) inset; }

</style>
</head>
<body>
<header class="">
  <input id="file" type="file" accept=".json" style="display:none" />
  <button id="btnFile" class="iconBtn" title="Open JSON">üìÑ</button>
  <button id="btnPlay" class="iconBtn" title="Play/Pause" disabled>‚ñ∂</button>
  <div class="chip">
    <span class="muted">Speed</span>
    <select id="speedSelect" title="Playback Speed Changer">
      <option value="0.25">0.25√ó</option>
      <option value="0.5">0.5√ó</option>
      <option value="1" selected>1√ó</option>
      <option value="2">2√ó</option>
      <option value="4">4√ó</option>
      <option value="8">8√ó</option>
    </select>
  </div>
  <button id="btnFit" class="iconBtn" title="Maximize field (square)">‚§¢</button>
  <button id="btnToggleFloat" class="iconBtn" title="Toggle Info Window">üìã</button>
  <div class="chip">
    <span class="muted">Field</span>
    <select id="fieldSelect" title="Field image Selector">
      <option value="">No field image</option>
    </select>
  </div>
  <button class="iconBtn pillAction" id="btnClearField" style="font-size: 12px" title="Clear field">‚ùå</button>
  <button id="btnHelp" class="iconBtn" title="Help">?</button>
  <span class="grow muted" id="status">Drop a viewer JSON file.</span>
</header>

<div id="helpModal" class="modal" hidden>
  <div class="modalBackdrop"></div>
  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modalHeader">
      <div id="helpTitle" style="font-weight:900;font-size:16px">JerryForge Viewer ‚Äî Help</div>
      <button id="btnHelpClose" class="iconBtn" title="Close">‚úï</button>
    </div>
    <div class="modalBody">
      <p style="margin-top:0">
        This is an offline viewer for robot logs produced by the JerryForge / SfxLib PROS library.
      </p>
      <p>
        Use it with JSON files generated by:
        <a href="https://github.com/lewispinstein-hue/PROS-JerryForge-Logger-Demo/tree/main/tools/JerryForge" target="_blank" rel="noreferrer">
          PROS-JerryForge-Logger-Demo
        </a>
      </p>
      <div style="margin-top:10px">
        <div style="font-weight:850;margin-bottom:6px">Main elements</div>
        <ul style="margin:0;padding-left:18px">
          <li><b>Field view</b>: robot path + pose, watches, hover/click to preview/lock.</li>
          <li><b>Timeline</b>: scrub through time; hover previews, click jumps.</li>
          <li><b>Sidebar</b>: config, watches list, poses list.</li>
          <li><b>Floating info window</b>: shows details of hovered point, including closest watch values.</li>
        </ul>
      </div>
      <div style="margin-top:10px" class="muted">
        Tip: Drag the thin handles to resize/collapse the sidebar (left) and timeline (bottom).
      </div>
    </div>
  </div>
</div>

<div id="floatingInfo" class="hidden">
  <div id="floatHeader">
    <div class="float-title">
      <span class="float-title-text">Point Details</span>
      <span class="float-subtitle" id="fcount">Point: ‚Äî/‚Äî</span>
    </div>
    <button id="btnCloseFloat" class="iconBtn" aria-label="Close">‚úï</button>
  </div>

  <div id="floatBody">
    <div class="float-section">
      <div class="float-row"><span class="k">X</span><span class="v" id="fx">‚Äî</span></div>
      <div class="float-row"><span class="k">Y</span><span class="v" id="fy">‚Äî</span></div>
      <div class="float-row"><span class="k">Œ∏</span><span class="v" id="ft">‚Äî</span></div>
    </div>

    <div class="divider"></div>

    <div class="float-section">
        <div class="float-row"><span class="k">Time</span><span class="v" id="ftime">‚Äî</span></div>
        <div class="float-row"><span class="k">Œî</span><span class="v" id="fdeltat">‚Äî</span></div>
    </div>

    <div class="divider"></div>

    <div class="float-section">
      <div class="float-row"><span class="k">Avg Vel</span><span class="v" id="favg">‚Äî</span></div>
      <div class="float-row"><span class="k">L Vel</span><span class="v" id="flv">‚Äî</span></div>
      <div class="float-row"><span class="k">R Vel</span><span class="v" id="frv">‚Äî</span></div>
    </div>
    <div class="divider"></div>

    <div class="float-watch" id="fwatchblock">
      <div class="float-watch-head">
        <span class="chip" id="fwatchclickable">Closest Watch</span>
        <span class="float-watch-time" id="fwatchtime">‚Äî</span>
      </div>

      <div class="float-row"><span class="k">Label</span><span class="v v-soft" id="fwatchlabel">‚Äî</span></div>
      <div class="float-row"><span class="k">Value</span><span class="v v-soft" id="fwatchvalue">‚Äî</span></div>
    </div>
  </div>

  <div id="floatResizer" aria-hidden="false"></div>
</div>


<div class="app">
  <div class="row">

    <div id="left">
      <div class="leftTopBar">
        <div class="leftTopRow">
          <button class="iconBtn pillAction" id="btnLeftStop" title="Stop">Stop</button>
          <button class="iconBtn pillAction" id="btnLeftConnect" title="Connect">Connect</button>

          <div></div>

          <div class="leftRefreshChip" title="Refresh + interval">
            <button class="leftRefreshBtn" id="btnLeftRefresh" type="button">Refresh</button>
            <select id="leftRefreshInterval" aria-label="Refresh interval">
              <option value="0">off</option>
              <option value="100">100ms</option>
              <option value="121">121ms (SFX HZ)</option>
              <option value="250">250ms</option>
              <option value="500" selected>500ms</option>
              <option value="1000">1s</option>
              <option value="2000">2s</option>
              <option value="5000">5s</option>
            </select>
          </div>
        </div>
      </div>

      <div class="leftBody">
        <textarea id="liveWin" class="monoText" readonly wrap="soft" spellcheck="false" aria-label="Live window"></textarea>
      </div>
    </div>

    <div id="vSplitL" class="splitterV" title="Drag to resize"></div>

    <div id="canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div id="vSplit" class="splitterV" title="Drag to resize"></div>

    <div id="right">
      <div class="section">
        <details open id="secGeneral">
          <summary>
            <span>Config</span>
            <span class="pill" id="fmt">no file</span>
          </summary>
          <div class="detailsBody">
            <div style="font-weight:800" id="runName">‚Äî</div>
            <div class="muted" id="runMeta">‚Äî</div>

            <div style="margin-top:12px" class="grid2">
              <div>
                <label>Units (interpret input poses as)</label>
                <select id="unitsSelect">
                  <option value="in">inches</option>
                  <option value="cm">centimeters</option>
                  <option value="ft">foot</option>
                  <option value="tiles">tiles (24 in)</option>
                </select>
              </div>
              <div>
                <label>Robot size (inches on field)</label>
                <div class="grid2">
                  <input id="robotW" type="number" step="1" value="12" />
                  <input id="robotH" type="number" step="1" value="12" />
                </div>
                <div class="muted" style="margin-top:6px">width / height</div>
              </div>
            </div>
            <div class="divider" style="margin:14px 0;"></div>
            <div id="robotImgControls" style="margin-top:12px" hidden>
              <div class="grid2">
                <div>
                  <label>Img Scale</label>
                  <input id="robotImgScale" type="number" step="0.05" value="1" />
                </div>
                <div>
                  <label>Img X Off</label>
                  <input id="robotImgOffX" type="number" step="0.25" value="0" />
                </div>
                <div>
                  <label>Img Y Off</label>
                  <input id="robotImgOffY" type="number" step="0.25" value="0" />
                </div>
                <div>
                  <label>Img Rot (¬∞)</label>
                  <input id="robotImgRot" type="number" step="1" value="0" />
                </div>
              </div>
            </div>
            <div class="divider" style="margin:14px 0;"></div>
            <div style="margin-top:12px" class="grid3"> 
              <div>
                <label>X Offset</label>
                <input id="offX" type="number" step="0.1" value="0" />
              </div>
              <div>
                <label>Y Offset</label>
                <input id="offY" type="number" step="0.1" value="0" />
              </div>
              <div>
                <label>Theta Offset</label>
                <input id="offTheta" type="number" step="1" value="0" />
              </div>
            </div>
              <div class="grid2" style="margin-bottom:10px">
              <div>
                <label>Min speed (normalize)</label>
                <input id="minSpeed" type="number" title="Minimum speed used for color normalization (red=slow)" step="1" value="0" />
              </div>
              <div>
                <label>Max speed (normalize)</label>
                <input id="maxSpeed" type="number" title="Maximum speed used for color normalization (green=fast)" step="1" value="127" />
              </div>
            </div>
            <div class="divider" style="margin:14px 0;"></div>
            <div class="statsPanel">
              <div class="statsHeader">
                <div class="statsTitle">Stats</div>
                <div class="statsHint" id="statsMarker">Updates when a path is loaded</div>
              </div>

              <div class="kvs" id="stats"></div>
            </div>

</div> 
        </details>
      </div>

      <div class="section">
        <details open id="secWatches">
          <summary>
            <span>Watches</span>
            <span class="pill" id="watchCount">‚Äî</span>
          </summary>
          <div class="detailsBody">
            <div class="rowline" style="margin-bottom:8px">
              <span class="muted">Sort</span>
              <select id="watchSort" style="margin-left:auto">
                <option value="level">level</option>
                <option value="time" selected>time</option>
                <option value="-time">-time</option>
                <option value="value">value</option>
              </select>
            </div>

            <div id="watchList"></div>
            <div class="muted" style="margin-top:10px">
              Click a watch to highlight it on the field and on the timeline.
            </div>
          </div>
        </details>
      </div>

      
      <div class="section">
        <details open id="secPoses">
          <summary>
            <span>Poses</span>
            <span class="pill" id="poseCount">‚Äî</span>
          </summary>
          <div class="detailsBody">
            <div class="muted" style="margin-bottom:8px">Click a pose to jump.</div>
            <div id="poseList" title="Click a pose to jump the robot to that recorded moment" style="max-height: 40vh; overflow:auto; border:1px solid var(--line); border-radius:10px;"></div>
          </div>
        </details>
      </div>

    </div>
  </div>

  <div id="hSplit" class="splitterH" title="Drag to resize timeline"></div>

  <!-- Bottom timeline bar -->
  <div id="timelineBar">
    <div id="timelineTop">
      <div id="timelineLeft">
        <span class="pill" id="timePill">Time: ‚Äî</span>
        <span class="pill" id="deltaPill">Œî: ‚Äî</span> 
        <span class="pill" id="pointPill">Point: ‚Äî/‚Äî</span>
      </div>
      <span class="pill poseReadout" id="posePill">
        <span class="kv"><span class="k">X: </span><span class="v" id="poseX">‚Äî</span></span>
        <span class="kv"><span class="k">Y: </span><span class="v" id="poseY">‚Äî</span></span>
        <span class="kv"><span class="k">Œ∏: </span><span class="v" id="poseTh">‚Äî</span></span>
        <span class="kv"><span class="k">Speed: </span><span class="v" id="poseSn">‚Äî</span></span>
      </span>
    </div>
    <canvas id="timelineCanvas"></canvas>
    <div id="timelineHint" class="muted">
      Hover: preview robot at time ‚Ä¢ Click: set time ‚Ä¢ Watch dots are clickable
    </div>
  </div>
</div>

<script>
(() => {
  const root = document.documentElement;
  // Live streaming state shared across handlers (avoids TDZ issues)
  window.__live = window.__live || { connected: false, streaming: false };

  const canvas = document.getElementById('c');
  // Track last mouse position (for small popups)
  let lastMouseClient = { x: 20, y: 20 };
  window.addEventListener('mousemove', (e) => { lastMouseClient = { x: e.clientX, y: e.clientY }; }, { passive: true });

  const ctx = canvas.getContext('2d');
  const timelineCanvas = document.getElementById('timelineCanvas');
  const tctx = timelineCanvas.getContext('2d');

  const statusEl = document.getElementById('status');
  const fileEl = document.getElementById('file');
  const btnPlay = document.getElementById('btnPlay');
  const btnFit = document.getElementById('btnFit');
  const btnFile = document.getElementById('btnFile');
  const btnHelp = document.getElementById('btnHelp');
  const btnLeftStop = document.getElementById('btnLeftStop');
  const btnLeftConnect = document.getElementById('btnLeftConnect');
  const btnLeftRefresh = document.getElementById('btnLeftRefresh');
  const leftRefreshInterval = document.getElementById('leftRefreshInterval');
  const liveWin = document.getElementById('liveWin');
  const helpModal = document.getElementById('helpModal');
  const btnHelpClose = document.getElementById('btnHelpClose');
  const speedSelect = document.getElementById('speedSelect');
  const watchSort = document.getElementById('watchSort');
  const vSplit = document.getElementById('vSplit');
  const hSplit = document.getElementById('hSplit');
  const timePill = document.getElementById('timePill');
  const deltaPill = document.getElementById('deltaPill');
  const pointPill = document.getElementById('pointPill');
  const posePill = document.getElementById('posePill');

  const rightEl = document.getElementById('right');
  const leftEl = document.getElementById('left');
  const vSplitL = document.getElementById('vSplitL');
  const rowGrid = document.querySelector('.row');

  const timelineBar = document.getElementById('timelineBar');
  const timelineTop = document.getElementById('timelineTop');
  const timelineHint = document.getElementById('timelineHint');

  const runName = document.getElementById('runName');
  const runMeta = document.getElementById('runMeta');
  const fmt = document.getElementById('fmt');
  const statsEl = document.getElementById('stats');
  const watchList = document.getElementById('watchList');
  const watchCount = document.getElementById('watchCount');
  const secWatches = document.getElementById('secWatches');
  const fieldSelect = document.getElementById('fieldSelect');

  const poseList = document.getElementById('poseList');
  const poseCount = document.getElementById('poseCount');

  const offXEl = document.getElementById('offX');
  const offYEl = document.getElementById('offY');
  const offThetaEl = document.getElementById('offTheta');
  const unitsSelect = document.getElementById('unitsSelect');
  const robotWEl = document.getElementById('robotW');
  const robotHEl = document.getElementById('robotH');
  const robotImgControlsEl = document.getElementById('robotImgControls');
  const robotImgScaleEl = document.getElementById('robotImgScale');
  const robotImgOffXEl = document.getElementById('robotImgOffX');
  const robotImgOffYEl = document.getElementById('robotImgOffY');
  const robotImgRotEl = document.getElementById('robotImgRot');
  const minSpeedEl = document.getElementById('minSpeed');
  const maxSpeedEl = document.getElementById('maxSpeed');

  // --- FIELD IMAGES ---
  const FIELD_IMAGES = [
    { key: "./assets/match_field_2025-2026_pushback.png", label: "Field: Match Field" },
    { key: "./assets/skills_field_2025-2026_pushback.png", label: "Field: Skills Field" },
  ];

  // Default field image
  const DEFAULT_FIELD_KEY = FIELD_IMAGES[0].key;

  // Field bounds in INCHES (default view when no Fit)
  const FIELD_BOUNDS_IN = { minX: -72, maxX: 72, minY: -72, maxY: 72, pad: 30 };

  const WATCH_TOL_MS = 40; // Controls the ¬± time that determines which pose a watch attaches to
  const COLLAPSE_PX_TIMELINE = 140; // When the timeline collapses away
  const COLLAPSE_PX_SIDEBAR = 275; 

  const COLLAPSE_PX_LEFTSIDEBAR = 370; // When the left sidebar collapses away
  const DBLCLICK_COLLAPSE_LEFTSIDEBAR = true;
  const MAX_PX_LIVEWIN = 650; // Max width for left live window panel

  const MAX_TIMELINE_H_PX = 350; // Height at which timeline stops growing
  const MAX_SIDEBAR_W_PX = 400; // Width at which sidebar stops growing

  const HOVER_PIXEL_TOL = 14;
  const TRACK_HOVER_PAD_PX = 12; // How close to the track before snapping on

  const OFFSET_MAX = 100; // Max offset in either direction

  const CANVAS_ZOOM_MAX = 12; // Max zoom in
  const CANVAS_ZOOM_MIN = 0.7; // Max zoom out

  const minW = 50, maxW = 400;
  const minH = 49, maxH = 600; // Bring minH back to 241
  let data = null;

  // Raw poses are stored in FILE units; we convert to inches for rendering.
  // Fields: t, x, y, theta, l_vel, r_vel, speed_raw, speed_norm
  let rawPoses = [];

  // Watches: normalized
  let watches = [];
  let watchMarkers = []; // {watch, t, pose(in), ok, idx, dt}

  let selectedWatch = null;       // { marker }
  let selectedIndex = 0;          // nearest pose index for "locked" selection
  let hoverTimelineTime = null;   // preview time on timeline (ms)
  let timelineHoverSaved = null;  // { index, lockActive, lockPose, lockIndex }

  let hoverWatch = null;

  // Track preview + lock
  let trackHover = null;          // { pose, idxNearest }
  let trackHoverSavedIndex = null;
  let trackLockActive = false;
  let trackLockPose = null;       // pose in inches
  let trackLockIndex = null;

  // playback
  let playing = false;
  let raf = null;
  let playTimeMs = null;
  let lastWall = null;
  let playRate = 1;

  // world->screen
  let bounds = { ...FIELD_BOUNDS_IN };
  let scale = 1;
  let offsetXpx = 0;
  let offsetYpx = 0;

  // field image
  let fieldImg = null;
  // optional robot image (./robot_image.png)
  let robotImg = null;
  let robotImgOk = false;
  let robotImgLoadTried = false;

  const robotImgTx = { scale: 1, offXIn: 0, offYIn: 0, rotDeg: 0 };

  // view controls (pan/zoom) + square maximize mode
  let squareMode = true;
  let viewZoom = 1;
  let viewPanXpx = 0;
  let viewPanYpx = 0;
  let baseScale = 1;
  let baseOffsetXpx = 0;
  let baseOffsetYpx = 0;

  let isPanning = false;
  let panArmed = false;
  let panPointerId = null;
  let panStart = { x: 0, y: 0, panX: 0, panY: 0 };
  let suppressNextClick = false;


  // offsets: entered in selected units, stored as inches for rendering
  const offsetsIn = { x: 0, y: 0, theta: 0 };
  let unitsToInFactor = 1;

  // -------- utilities --------
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function normalizeDeg(d) { let x = d % 360; if (x < 0) x += 360; return x; }
  function angLerpDeg(a, b, t) {
    a = normalizeDeg(a); b = normalizeDeg(b);
    let diff = (b - a + 540) % 360 - 180;
    return normalizeDeg(a + diff * t);
  }
  function fmtNum(v, d=2) { if (typeof v !== "number" || !isFinite(v)) return "‚Äî"; return v.toFixed(d); }
  function setStatus(msg) { statusEl.textContent = msg; }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (c) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c]));
  }

  function toNumMaybe(v) {
    if (typeof v === "number" && isFinite(v)) return v;
    if (typeof v === "string") {
      const n = Number(v.trim());
      if (isFinite(n)) return n;
    }
    return null;
  }

  function levelStyle(levelRaw) {
    const L = String(levelRaw || "INFO").toUpperCase();
    if (L.includes("ERROR") || L.includes("FATAL")) return { name:"ERROR", fill:"rgb(255,77,77)", text:"#081018" };
    if (L.includes("WARN")) return { name:"WARN", fill:"rgb(255,212,77)", text:"#081018" };
    if (L.includes("DEBUG")) return { name:"DEBUG", fill:"rgb(154,167,187)", text:"#081018" };
    return { name:"INFO", fill:"rgb(77,255,136)", text:"#081018" };
  }

  function robotDimsInches() {
    const w = Number(robotWEl.value || 12);
    const h = Number(robotHEl.value || 12);
    return { w: Math.max(1, w), h: Math.max(1, h) };
  }

  // -------- units/offsets --------
  function setUnitsFactorFromSelect(value) {
    if (value === "cm") unitsToInFactor = 1 / 2.54;
    else if (value === "ft") unitsToInFactor = 12;
    else if (value === "tiles") unitsToInFactor = 24;
    else unitsToInFactor = 1;
  }

  function inferUnitsFromMeta(metaUnits) {
    const u = String(metaUnits || "").toLowerCase().trim();
    if (!u) return "in";
    if (u.includes("tile")) return "tiles";
    if (u.includes("cm") || u.includes("cent")) return "cm";
    if (u === "ft" || u.includes("foot") || u.includes("feet")) return "ft";
    if (u.includes("in")) return "in";
    return "in";
  }

  function updateOffsetsFromInputs() {
    const ux = Number(offXEl.value || 0);
    const uy = Number(offYEl.value || 0);
    const ut = Number(offThetaEl.value || 0);

    offsetsIn.x = ux * unitsToInFactor;
    offsetsIn.y = uy * unitsToInFactor;
    offsetsIn.theta = ut;

    recomputeWatchMarkers();
    draw();
    updatePoseReadout();
    drawTimeline();
  }

  // -------- speed normalization (single source of truth) --------
  function getMinMaxSpeed() {
    let minV = Number(minSpeedEl.value);
    let maxV = Number(maxSpeedEl.value);
    minV = (isFinite(minV) ? minV : 0);
    maxV = (isFinite(maxV) ? maxV : 127);
    if (minV > maxV) { const tmp = minV; minV = maxV; maxV = tmp; }
    return { minV, maxV };
  }

  function computeSpeedNorm() {
    const { minV, maxV } = getMinMaxSpeed();
    const denom = (maxV - minV) || 1;
    for (const p of rawPoses) {
      const s = Math.abs(p.speed_raw ?? 0);
      p.speed_norm = clamp((s - minV) / denom, 0, 1);
    }
  }

  function heatColorFromNorm(n) {
    const t0 = clamp(n, 0, 1);

    // If vel is ¬±127 scaled and n was made from it, then:
    // vel<=5 corresponds to n <= 5/127.
    const lowCut = 5 / 127;

    // Force "dark red" for very low speeds
    if (t0 <= lowCut) {
      // dark red, slightly transparent
      return `rgba(120, 10, 10, 1)`;
    }

    // 2) Remap (lowCut..1) -> (0..1) so everything above 5 has visible range
    const t = (t0 - lowCut) / (1 - lowCut); // 0..1
    const u = 1 - t; // u=1 red, u=0 green

    let r, g, b;

    if (u <= 0.15) {
      const a = u / 0.33;
      r = 40 + a * (255 - 40);
      g = 220;
      b = 80;
    } else if (u <= 0.66) {
      const a = (u - 0.33) / 0.33;
      r = 255;
      g = 220 - a * 140;
      b = 80 - a * 40;
    } else {
      const a = (u - 0.66) / 0.34;
      r = 255;
      g = 80 - a * 70;
      b = 40 - a * 30;
    }

    return `rgba(${Math.round(r)},${Math.round(g)},${Math.round(b)},0.88)`;
  }

  // -------- pose conversion --------
  function poseToInches(p) {
    return {
      t: (typeof p.t === "number") ? p.t : null,
      x: (p.x ?? 0) * unitsToInFactor + offsetsIn.x,
      y: (p.y ?? 0) * unitsToInFactor + offsetsIn.y,
      theta: normalizeDeg((p.theta ?? 0) + offsetsIn.theta),
      l_vel: (typeof p.l_vel === "number") ? p.l_vel : null,
      r_vel: (typeof p.r_vel === "number") ? p.r_vel : null,
      speed_raw: (typeof p.speed_raw === "number") ? p.speed_raw : null,
      speed_norm: (typeof p.speed_norm === "number") ? p.speed_norm : 0,
    };
  }

  function getPosesInches() { return rawPoses.map(poseToInches); }

  // -------- canvas sizing/transform --------
  function computeTransform() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const pad = bounds.pad;
    const worldW = (bounds.maxX - bounds.minX) || 1;
    const worldH = (bounds.maxY - bounds.minY) || 1;

    baseScale = Math.min((w - pad*2) / worldW, (h - pad*2) / worldH);

    const side = squareMode ? Math.min(w, h) : null;
    const viewW = squareMode ? side : w;
    const viewH = squareMode ? side : h;

    // these center the square viewport
    const vx = squareMode ? (w - side) / 2 : 0;
    const vy = squareMode ? (h - side) / 2 : 0;

    baseOffsetXpx = vx + pad - bounds.minX * baseScale;
    baseOffsetYpx = vy + pad + bounds.maxY * baseScale;

    scale = baseScale * viewZoom;
    offsetXpx = baseOffsetXpx * viewZoom + viewPanXpx;
    offsetYpx = baseOffsetYpx * viewZoom + viewPanYpx;
  }

  function worldToScreen(xIn, yIn) {
    return { x: offsetXpx + xIn * scale, y: offsetYpx - yIn * scale };
  }

  function screenToWorld(xPx, yPx) {
    return { x: (xPx - offsetXpx) / (scale || 1), y: (offsetYpx - yPx) / (scale || 1) };
  }

  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    computeTransform();
    draw();
  }

  function layoutTimelineCanvas() {
    if (!timelineCanvas || !timelineBar) return;
    if (timelineBar.classList.contains('isCollapsed')) return;

    // Ensure we never clip the bottom: compute available height.
    const barH = timelineBar.getBoundingClientRect().height;
    const topH = timelineTop ? timelineTop.getBoundingClientRect().height : 0;
    const hintH = timelineHint ? timelineHint.getBoundingClientRect().height : 0;
    const padding = 10 + 10; // rough internal padding
    const avail = Math.max(144, barH - topH - hintH - padding);
    timelineCanvas.style.height = `${avail}px`;
  }

  function resizeTimeline() {
    layoutTimelineCanvas();
    const dpr = window.devicePixelRatio || 1;
    const rect = timelineCanvas.getBoundingClientRect();
    timelineCanvas.width = Math.max(1, Math.floor(rect.width * dpr));
    timelineCanvas.height = Math.max(1, Math.floor(rect.height * dpr));
    tctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    drawTimeline();
  }

  // -------- field images --------
  function loadFieldOptions() {
    fieldSelect.innerHTML = `<option value="no">No field image</option>`;
    for (const f of FIELD_IMAGES) {
      const opt = document.createElement('option');
      opt.value = f.key;
      opt.textContent = f.label;
      fieldSelect.appendChild(opt);
    }
  }

  async function loadFieldImage(filename) {
    if (!filename) { fieldImg = null; draw(); return; }
    const img = new Image();
    img.onload = () => { fieldImg = img; draw(); };
    img.onerror = () => { fieldImg = null; setStatus(`Could not load field image: ${filename}`); draw(); };
    img.src = filename;
    setStatus(`Loading field image: ${filename}...`);
  }

  function loadRobotImage() {
    if (robotImgLoadTried) return;
    robotImgLoadTried = true;

    const img = new Image();
    img.onload = () => {
      robotImg = img;
      robotImgOk = true;
      if (robotImgControlsEl) robotImgControlsEl.hidden = false;
      draw();
    };
    img.onerror = () => {
      robotImg = null;
      robotImgOk = false;
      if (robotImgControlsEl) robotImgControlsEl.hidden = true;
      setStatus("robot_image.png not found or failed to load; using default robot box.");
      draw();
    };
    img.src = "./robot_image.png";
  }

  function drawFirstField() {
    loadFieldOptions();

    // Set the default selection and trigger the load
    const defaultField = FIELD_IMAGES.find(f => f.key === DEFAULT_FIELD_KEY);
    
    if (defaultField) {
      fieldSelect.value = defaultField.key; 
      loadFieldImage(defaultField.key); 
    }
  }

  // -------- time helpers --------
  function timeRange() {
    const t0 = rawPoses[0]?.t;
    const tN = rawPoses[rawPoses.length-1]?.t;
    if (typeof t0 !== "number" || typeof tN !== "number" || tN <= t0) return null;
    return { t0, tN };
  }

  function findFloorIndexByTime(tMs) {
    const poses = rawPoses;
    if (!poses.length) return -1;
    let lo = 0, hi = poses.length - 1;
    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      const tm = poses[mid].t ?? -Infinity;
      if (tm <= tMs) lo = mid + 1;
      else hi = mid - 1;
    }
    return clamp(hi, 0, poses.length - 1);
  }

  function interpolatePoseAtTime(tMs) {
    if (!rawPoses.length) return null;
    const i = findFloorIndexByTime(tMs);
    const p0 = rawPoses[i];
    if (i >= rawPoses.length - 1) return poseToInches({ ...p0, t: p0.t });

    const p1 = rawPoses[i+1];
    const t0 = p0.t ?? tMs;
    const t1 = p1.t ?? t0;
    const denom = (t1 - t0) || 1;
    const a = clamp((tMs - t0) / denom, 0, 1);

    const x = (p0.x ?? 0) + ((p1.x ?? 0) - (p0.x ?? 0)) * a;
    const y = (p0.y ?? 0) + ((p1.y ?? 0) - (p0.y ?? 0)) * a;
    const theta = angLerpDeg(p0.theta ?? 0, p1.theta ?? 0, a);

    const l_vel = (p0.l_vel ?? 0) + ((p1.l_vel ?? 0) - (p0.l_vel ?? 0)) * a;
    const r_vel = (p0.r_vel ?? 0) + ((p1.r_vel ?? 0) - (p0.r_vel ?? 0)) * a;

    const s0 = (p0.speed_raw ?? 0), s1 = (p1.speed_raw ?? 0);
    const speed_raw = s0 + (s1 - s0) * a;
    const speed_norm = (p0.speed_norm ?? 0) + ((p1.speed_norm ?? 0) - (p0.speed_norm ?? 0)) * a;

    // feed in file units and norm; poseToInches will reapply offsets for x/y/theta
    return poseToInches({ t: tMs, x, y, theta, l_vel, r_vel, speed_raw, speed_norm });
  }

  function nearestIndexWithinTol(tMs, tolMs) {
    if (!rawPoses.length) return null;
    const i0 = findFloorIndexByTime(tMs);
    const cands = [i0, Math.min(i0+1, rawPoses.length-1)];
    let best = null;
    for (const i of cands) {
      const tt = rawPoses[i].t;
      if (typeof tt !== "number") continue;
      const dt = Math.abs(tt - tMs);
      if (best === null || dt < best.dt) best = { idx: i, dt };
    }
    if (best && best.dt <= tolMs) return best;
    return null;
  }

  // -------- watches --------
  function normalizeWatches(arr) {
    const out = [];
    if (!Array.isArray(arr)) return out;

    for (const w of arr) {
      if (!w || typeof w !== "object") continue;
      const tRaw = (w.t ?? w.timestamp ?? w.time ?? w.ms);
      const t = toNumMaybe(tRaw);
      if (t == null) continue;

      out.push({
        t,
        level: w.level ?? w.lvl ?? w.severity ?? "INFO",
        label: w.label ?? w.name ?? "",
        value: (w.value ?? w.val ?? w.message ?? ""),
      });
    }
    out.sort((a,b) => a.t - b.t);
    return out;
  }

  function recomputeWatchMarkers() {
    watchMarkers = [];
    for (const w of watches) {
      const t = w.t;
      const near = nearestIndexWithinTol(t, WATCH_TOL_MS);
      if (near) {
        const p = rawPoses[near.idx];
        watchMarkers.push({ watch: w, t, ok: true, dt: near.dt, pose: poseToInches(p), idx: near.idx });
      } else {
        const ip = interpolatePoseAtTime(t);
        if (ip) watchMarkers.push({ watch: w, t, ok: false, dt: null, pose: ip, idx: null });
      }
    }
  }

  // watchMarkersByTime is used for fast "last watch hit" lookup during playback
  let watchMarkersByTime = [];

  function rebuildWatchMarkersByTime() {
    watchMarkersByTime = watchMarkers.slice().sort((a,b) => (a.t ?? 0) - (b.t ?? 0));
  }

  function lastWatchAtTime(tMs) {
    if (!watchMarkersByTime.length) return null;
    let lo = 0, hi = watchMarkersByTime.length - 1;
    if ((watchMarkersByTime[0].t ?? 0) > tMs) return null;
    while (lo < hi) {
      const mid = Math.ceil((lo + hi) / 2);
      const tm = watchMarkersByTime[mid].t ?? 0;
      if (tm <= tMs) lo = mid; else hi = mid - 1;
    }
    return watchMarkersByTime[lo];
  }

  function scrollIntoViewIfNeeded(container, el, pad=10) {
    if (!container || !el) return;
    const c = container.getBoundingClientRect();
    const r = el.getBoundingClientRect();
    if (r.top >= c.top + pad && r.bottom <= c.bottom - pad) return;
    const topDelta = (r.top - (c.top + pad));
    const botDelta = (r.bottom - (c.bottom - pad));
    if (topDelta < 0) container.scrollTop += topDelta;
    else if (botDelta > 0) container.scrollTop += botDelta;
  }

  function highlightWatchInList(tMs, doScroll) {
    const items = watchList.querySelectorAll(".watchItem");
    items.forEach(el => el.classList.remove("selected"));
    const el = watchList.querySelector(`.watchItem[data-t="${CSS.escape(String(tMs))}"]`);
    if (el) {
      el.classList.add("selected");
      if (doScroll) requestAnimationFrame(() => scrollIntoViewIfNeeded(watchList, el, 12));
    }
  }

  // --- Watch popup (tiny, click to show, click elsewhere to dismiss) ---
  const watchPopup = document.getElementById('watchPopup');
  let watchPopupOpen = false;

  function hideWatchPopup() {
    if (!watchPopup) return;
    watchPopup.hidden = true;
    watchPopupOpen = false;
  }

  function fmtPose(p) {
    if (!p) return "‚Äî";
    const x = (p.x ?? 0).toFixed(1);
    const y = (p.y ?? 0).toFixed(1);
    const th = (p.theta ?? 0).toFixed(1);
    return `X: ${x}in, Y: ${y}in, Œ∏: ${th}¬∞`;
  }

  function showWatchPopup(marker, clickPos) {
    if (!watchPopup || !marker) return;

    const w = marker.watch || {};
    const pose = marker.pose || interpolatePoseAtTime(marker.t);
    const poseStr = fmtPose(pose);

    const tStr = (marker.t != null) ? `${marker.t}ms` : "‚Äî";
    const watchStr = w.watch || w.name || w.key || "watch";
    const labelStr = w.label || "‚Äî";
    const valStr = (w.value == null) ? "‚Äî" : String(w.value);

    watchPopup.innerHTML = `
      <div class="row"><div class="k">time</div><div class="v">${escapeHtml(tStr)}</div></div>
      <div class="row"><div class="k">pose</div><div class="v">${escapeHtml(poseStr)}</div></div>
      <div class="row"><div class="k">watch</div><div class="v">${escapeHtml(String(watchStr))}</div></div>
      <div class="row"><div class="k">label</div><div class="v">${escapeHtml(String(labelStr))}</div></div>
      <div class="row"><div class="k">value</div><div class="v">${escapeHtml(valStr)}</div></div>
    `;

    // Position above click, clamp to viewport
    const x = (clickPos && isFinite(clickPos.x)) ? clickPos.x : (lastMouseClient?.x ?? 20);
    const y = (clickPos && isFinite(clickPos.y)) ? clickPos.y : (lastMouseClient?.y ?? 20);

    watchPopup.hidden = false;
    watchPopupOpen = true;

    // measure after display
    requestAnimationFrame(() => {
      const rect = watchPopup.getBoundingClientRect();
      let left = x - rect.width * 0.5;
      let top = y - rect.height - 10;

      left = clamp(left, 8, window.innerWidth - rect.width - 8);
      if (top < 8) top = clamp(y + 10, 8, window.innerHeight - rect.height - 8);

      watchPopup.style.left = `${left}px`;
      watchPopup.style.top = `${top}px`;
    });
  }

  // dismiss by clicking anywhere else
  document.addEventListener('mousedown', (e) => {
    if (!watchPopupOpen) return;
    if (watchPopup && watchPopup.contains(e.target)) return;
    hideWatchPopup();
  }, { capture: true });


  function renderWatchList() {
    watchList.innerHTML = "";
    watchCount.textContent = `${watchMarkers.length}`;

    const mode = watchSort ? watchSort.value : "time";
    const items = watchMarkers.slice();

    const valKey = (v) => {
      if (v == null) return { t: 2, n: 0, s: "" };
      if (typeof v === "boolean") return { t: 0, n: v ? 1 : 0, s: String(v) };
      if (typeof v === "number") return { t: 1, n: v, s: "" };
      return { t: 0, n: 0, s: String(v) };
    };

    items.sort((a,b) => {
      const wa = a.watch || {};
      const wb = b.watch || {};
      if (mode === "level") return String(wa.level||"").localeCompare(String(wb.level||""));
      if (mode === "time") return (a.t ?? 0) - (b.t ?? 0);
      if (mode === "-time") return (b.t ?? 0) - (a.t ?? 0);
      if (mode === "value") {
        const ka = valKey(wa.value);
        const kb = valKey(wb.value);
        if (ka.t !== kb.t) return ka.t - kb.t;
        if (ka.t === 1) return (ka.n - kb.n);
        return ka.s.localeCompare(kb.s);
      }
      return 0;
    });

    for (const m of items) {
      const w = m.watch;
      const st = levelStyle(w.level);
      const label = w.label || "";
      const value = w.value ?? "";
      const t = m.t;

      const div = document.createElement("div");
      div.className = "watchItem";
      div.dataset.t = String(t);

      div.innerHTML = `
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap">
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <span class="pill level" style="background:${st.fill};color:${st.text}">${escapeHtml(st.name)}</span>
            <span style="font-weight:850;word-break:break-word">${escapeHtml(label)}</span>
          </div>
          <div class="muted">${t != null ? (t + "ms") : ""}</div>
        </div>
        <div class="bigValue">${escapeHtml(String(value))}</div>
      `;

      div.addEventListener('pointerdown', (ev) => {
        if (ev.button !== 0) return;
        ev.preventDefault();
        selectWatchMarker(m, true, { x: ev.clientX, y: ev.clientY });
      }, { passive:false });
      watchList.appendChild(div);
    }

    if (selectedWatch?.marker?.t != null) highlightWatchInList(selectedWatch.marker.t, false);
  }

  function selectWatchMarker(marker, fromUserClick=false, clickPos=null) {
    selectedWatch = { marker };

    // clicking a watch should override track lock/hover to avoid confusion
    clearTrackHover(true);
    clearTrackLock();

    const near = nearestIndexWithinTol(marker.t, WATCH_TOL_MS);
    if (near) {
      selectedIndex = near.idx;
      setStatus(`Watch @${marker.t}ms mapped to pose @${rawPoses[near.idx].t}ms (Œî=${near.dt}ms).`);
    } else {
      selectedIndex = findFloorIndexByTime(marker.t);
      setStatus(`Watch @${marker.t}ms shown via interpolation (no pose within ¬±${WATCH_TOL_MS}ms).`);
    }

    pause();
    hoverTimelineTime = null;
    timelineHoverSaved = null;

    highlightWatchInList(marker.t, fromUserClick);

    if (fromUserClick) {
      showWatchPopup(marker, clickPos);
    } else {
      hideWatchPopup();
    }
    highlightPoseInList();
    updatePoseReadout();
    requestDrawAll();
  }

  // -------- pose list --------
  function renderPoseList() {
    if (!poseList) return;
    poseList.innerHTML = "";
    if (!rawPoses.length) {
      poseCount.textContent = "‚Äî";
      return;
    }
    poseCount.textContent = `${rawPoses.length}`;
    const frag = document.createDocumentFragment();
    const maxItems = rawPoses.length; // keep simple
    for (let i=0; i<maxItems; i++) {
      const p = rawPoses[i];
      const t = (typeof p.t === "number") ? Math.round(p.t) : "‚Äî";
      const pi = poseToInches(p);
      const poseSummary = `X: ${(pi.x ?? 0).toFixed(1)}in, Y: ${(pi.y ?? 0).toFixed(1)}in, Œ∏: ${(pi.theta ?? 0).toFixed(1)}¬∞`;
      const div = document.createElement('div');
      div.className = 'poseItem';
      div.dataset.idx = String(i);
      div.innerHTML = `<div style="display:flex;justify-content:space-between;gap:10px">
        <div style="font-weight:800">#${i+1}</div>
        <div class="muted">${t}ms</div>
      </div>
      <div class="sub">${escapeHtml(poseSummary)}</div>`;
      div.addEventListener('pointerdown', (ev) => {
        if (ev.button !== 0) return;
        ev.preventDefault();

        pause();
        clearTrackHover(true);
        clearTrackLock();
        selectedWatch = null;
        selectedIndex = i;
        setStatus(`Jumped to pose #${i+1}.`);
        highlightPoseInList();
        updatePoseReadout();
        requestDrawAll();
      }, { passive:false });
      frag.appendChild(div);
    }
    poseList.appendChild(frag);
    highlightPoseInList();
  }

  function highlightPoseInList() {
    if (!poseList) return;
    const els = poseList.querySelectorAll('.poseItem');
    els.forEach(el => el.classList.toggle('selected', Number(el.dataset.idx) === selectedIndex));
    const el = poseList.querySelector(`.poseItem[data-idx="${CSS.escape(String(selectedIndex))}"]`);
    if (el) scrollIntoViewIfNeeded(poseList, el, 12);
    }

  // -------- drawing --------
  let drawQueued = false;
  function requestDrawAll() {
    if (drawQueued) return;
    drawQueued = true;
    requestAnimationFrame(() => {
      drawQueued = false;
      draw();
      drawTimeline();
    });
  }

  function drawField() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "#0b0f14";
    ctx.fillRect(0, 0, w, h);

    if (!fieldImg) return;
    const p0 = worldToScreen(bounds.minX, bounds.minY);
    const p1 = worldToScreen(bounds.maxX, bounds.maxY);
    const left = Math.min(p0.x, p1.x);
    const top = Math.min(p0.y, p1.y);
    const right = Math.max(p0.x, p1.x);
    const bottom = Math.max(p0.y, p1.y);

    ctx.globalAlpha = 0.95;
    ctx.drawImage(fieldImg, left, top, right - left, bottom - top);
    ctx.globalAlpha = 1.0;
  }

  function drawAxes() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const o = worldToScreen(0, 0);
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0, o.y); ctx.lineTo(w, o.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(o.x, 0); ctx.lineTo(o.x, h); ctx.stroke();
  }

  function drawPath() {
    const poses = getPosesInches();
    if (poses.length < 2) return;
    for (let i = 1; i < poses.length; i++) {
      const a = poses[i-1], b = poses[i];
      const pa = worldToScreen(a.x, a.y);
      const pb = worldToScreen(b.x, b.y);
      const grad = ctx.createLinearGradient(pa.x, pa.y, pb.x, pb.y);
      grad.addColorStop(0, heatColorFromNorm(a.speed_norm ?? 0));
      grad.addColorStop(1, heatColorFromNorm(b.speed_norm ?? 0));
      ctx.strokeStyle = grad;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y);
      ctx.lineTo(pb.x, pb.y);
      ctx.stroke();
    }
  }

  function drawWatchDots() {
    if (!watchMarkers.length) return;

    for (const m of watchMarkers) {
      const { pose, watch } = m;
      if (!pose) continue;
      const st = levelStyle(watch.level);
      const p = worldToScreen(pose.x, pose.y);

      const isHover = (hoverWatch === m);
      const r = isHover ? 5.6 : 4.2;
      const fillA = isHover ? 0.40 : 0.25;

      ctx.save();
      ctx.fillStyle = st.fill.replace("rgb(", "rgba(").replace(")", `,${fillA})`);
      ctx.strokeStyle = "rgba(255,255,255,0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    if (selectedWatch?.marker?.pose) {
      const st = levelStyle(selectedWatch.marker.watch.level);
      const pose = selectedWatch.marker.pose;
      const p = worldToScreen(pose.x, pose.y);

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 9.0, 0, Math.PI*2);
      ctx.stroke();

      ctx.fillStyle = st.fill.replace("rgb(", "rgba(").replace(")", ",0.35)");
      ctx.beginPath();
      ctx.arc(p.x, p.y, 6.5, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawRobot(pose, alpha=1.0) {
    if (!pose) return;
    const { w: wIn, h: hIn } = robotDimsInches();
    const center = worldToScreen(pose.x, pose.y);
    const wPx = wIn * scale;
    const hPx = hIn * scale;
    const thetaDeg = (pose.theta ?? 0);
    const thetaRad = (thetaDeg) * Math.PI / 180;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(center.x, center.y);
    ctx.rotate(thetaRad);

    const hasImg = robotImgOk && robotImg && robotImg.naturalWidth > 0 && robotImg.naturalHeight > 0;

    if (hasImg) {
      const s = clamp(Number(robotImgTx.scale) || 1, 0.05, 20);
      const ox = Number(robotImgTx.offXIn) || 0;
      const oy = Number(robotImgTx.offYIn) || 0;
      const r = (Number(robotImgTx.rotDeg) || 0) * Math.PI / 180;

      ctx.save();
      ctx.translate(ox * scale, -oy * scale);
      ctx.rotate(r);
      ctx.drawImage(robotImg, -(wPx*s)/2, -(hPx*s)/2, wPx*s, hPx*s);
      ctx.restore();
    } else {
      // default robot: translucent box + outline
      ctx.fillStyle = "rgba(255,255,255,0.14)";
      ctx.strokeStyle = "rgba(255,255,255,0.85)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.rect(-wPx/2, -hPx/2, wPx, hPx);
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = "rgba(255,255,255,0.98)";
      ctx.beginPath();
      ctx.moveTo(wPx/2, -hPx/2);
      ctx.lineTo(wPx/2,  hPx/2);
      ctx.stroke();
    }

    // heading arrow (useful even with image)
    const arrowLen = Math.max(wPx, hPx) * 0.85;
    ctx.strokeStyle = "rgba(255,255,255,0.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(arrowLen/2, 0);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(arrowLen/2, 0);
    ctx.lineTo(arrowLen/2 - 8, -5);
    ctx.lineTo(arrowLen/2 - 8,  5);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.fill();

    ctx.restore();
  }

  function currentDisplayPose() {
    // priority:
    // playing > timeline hover > track hover > track lock > selectedIndex
    if (playing) return playPose || interpolatePoseAtTime(playTimeMs);
    if (!playing && hoverTimelineTime != null) return interpolatePoseAtTime(hoverTimelineTime);
    if (!playing && !trackLockActive && trackHover?.pose) return trackHover.pose;
    if (!playing && trackLockActive && trackLockPose) return trackLockPose;
    const poses = getPosesInches();
    return poses[selectedIndex] || null;
  }

  function draw() {
    drawField();
    drawAxes();
    drawPath();
    drawWatchDots();

    const p = currentDisplayPose();
    if (p) drawRobot(p, 1.0);
  }

    // -------- timeline --------
  function indexToX(i) {
    const rect = timelineCanvas.getBoundingClientRect();
    const W = rect.width || 1;
    const n = Math.max(1, rawPoses.length - 1);
    return (clamp(i, 0, n) / n) * W;
  }

  function indexToTime(i) {
    i = clamp(i, 0, rawPoses.length - 1);
    return rawPoses[i]?.t ?? 0;
  }

  // Map a time to a *fractional pose index*, then to X.
  // This makes consecutive poses evenly spaced on the timeline.
  function timeToX(t) {
    if (!rawPoses.length) return 0;

    // binary search for floor index by time
    let lo = 0, hi = rawPoses.length - 1;
    while (lo < hi) {
      const mid = (lo + hi + 1) >> 1;
      const tm = rawPoses[mid]?.t ?? 0;
      if (tm <= t) lo = mid;
      else hi = mid - 1;
    }

    const i0 = lo;
    const i1 = Math.min(rawPoses.length - 1, i0 + 1);
    const t0 = rawPoses[i0]?.t ?? 0;
    const t1 = rawPoses[i1]?.t ?? t0;

    const frac = (t1 === t0) ? 0 : clamp((t - t0) / (t1 - t0), 0, 1);
    return indexToX(i0 + frac);
  }

  // Inverse: X -> fractional pose index -> interpolated time
  function xToTime(x) {
    if (!rawPoses.length) return 0;

    const rect = timelineCanvas.getBoundingClientRect();
    const W = rect.width || 1;

    const a = clamp(x / W, 0, 1);
    const f = a * (rawPoses.length - 1);

    const i0 = Math.floor(f);
    const i1 = Math.min(rawPoses.length - 1, i0 + 1);
    const frac = f - i0;

    const t0 = rawPoses[i0]?.t ?? 0;
    const t1 = rawPoses[i1]?.t ?? t0;
    return t0 + frac * (t1 - t0);
  }

  function timelinePickWatchDot(mx, my) {
    const r = 8;
    for (const m of watchMarkers) {
      const dx = mx - timeToX(m.t);
      const dy = my - 10;
      if ((dx*dx + dy*dy) <= r*r) return m;
    }
    return null;
  }

  function drawTimeline() {
    if (timelineBar.classList.contains('isCollapsed')) return;

    const rect = timelineCanvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;
    tctx.clearRect(0, 0, W, H);

    tctx.fillStyle = "rgba(16,23,32,0.55)";
    tctx.fillRect(0, 0, W, H);

    if (!rawPoses.length) return;
    const range = timeRange();
    if (!range) return;

    tctx.strokeStyle = "rgba(255,255,255,0.08)";
    tctx.lineWidth = 1;
    const major = 10;
    for (let i=0; i<=major; i++) {
      const x = (W * i) / major;
      tctx.beginPath(); tctx.moveTo(x, 0); tctx.lineTo(x, H); tctx.stroke();
    }

    // speed trace using norm
    tctx.lineWidth = 2;
    for (let i=1; i<rawPoses.length; i++) {
      const a = rawPoses[i-1], b = rawPoses[i];
      if (typeof a.t !== "number" || typeof b.t !== "number") continue;

      const xa = timeToX(a.t);
      const xb = timeToX(b.t);

      const ya = H - 6 - (clamp(a.speed_norm ?? 0, 0, 1) * (H - 12));
      const yb = H - 6 - (clamp(b.speed_norm ?? 0, 0, 1) * (H - 12));

      const grad = tctx.createLinearGradient(xa, ya, xb, yb);
      grad.addColorStop(0, heatColorFromNorm(a.speed_norm ?? 0));
      grad.addColorStop(1, heatColorFromNorm(b.speed_norm ?? 0));

      tctx.strokeStyle = grad;
      tctx.beginPath();
      tctx.moveTo(xa, ya);
      tctx.lineTo(xb, yb);
      tctx.stroke();
    }

    // watch dots
    for (const m of watchMarkers) {
      const st = levelStyle(m.watch.level);
      const x = timeToX(m.t);
      const y = 10;
      tctx.save();
      tctx.fillStyle = st.fill.replace("rgb(", "rgba(").replace(")", ",0.25)");
      tctx.strokeStyle = "rgba(255,255,255,0.95)";
      tctx.lineWidth = 2;
      tctx.beginPath();
      tctx.arc(x, y, 4.2, 0, Math.PI*2);
      tctx.fill();
      tctx.stroke();
      tctx.restore();
    }

    // selected marker: depends on current state
    let selT = null;
    if (playing) selT = playTimeMs;
    else if (trackLockActive && trackLockIndex != null) selT = rawPoses[trackLockIndex]?.t ?? null;
    else selT = rawPoses[selectedIndex]?.t ?? null;

    if (selT != null) {
      const x = timeToX(selT);
      tctx.strokeStyle = "rgba(255,255,255,0.95)";
      tctx.lineWidth = 2;
      tctx.beginPath();
      tctx.moveTo(x, 0);
      tctx.lineTo(x, H);
      tctx.stroke();
    }

    if (hoverTimelineTime != null) {
      const x = timeToX(hoverTimelineTime);
      tctx.strokeStyle = "rgba(255,255,255,0.5)";
      tctx.lineWidth = 1.5;
      tctx.beginPath();
      tctx.moveTo(x, 0);
      tctx.lineTo(x, H);
      tctx.stroke();
    }

    if (selectedWatch?.marker?.t != null) {
      const x = timeToX(selectedWatch.marker.t);
      const y = 10;
      tctx.save();
      tctx.strokeStyle = "rgba(255,255,255,0.95)";
      tctx.lineWidth = 2;
      tctx.beginPath();
      tctx.arc(x, y, 9.0, 0, Math.PI*2);
      tctx.stroke();
      tctx.restore();
    }
  }

  // Timeline time readout
  function updateDeltaReadout() {
    if (!data || !rawPoses.length) return;
    const lockedTime = rawPoses[selectedIndex]?.t || 0;
    
    // hoverTimelineTime is the time currently under the cursor
    const hoveredTime = hoverTimelineTime !== null ? hoverTimelineTime : lockedTime;
    const delta = Math.abs(hoveredTime - lockedTime) / 1000;
    if (deltaPill) {
    deltaPill.textContent = `Œî: ${delta.toFixed(2)}s`;    
    }
  }

  // --- Floating Window Logic ---
  const floatWin = document.getElementById('floatingInfo');
  const btnToggleFloat = document.getElementById('btnToggleFloat');
  const btnCloseFloat = document.getElementById('btnCloseFloat');
  const floatHeader = document.getElementById('floatHeader');
  const floatResizer = document.getElementById('floatResizer');
  
  // Toggle Visibility
  btnToggleFloat.onclick = (e) => {
    e.stopPropagation(); // Prevents event bubbling
    floatWin.classList.toggle('hidden');
  };

  btnCloseFloat.onclick = (e) => {
    e.stopPropagation();
    floatWin.classList.add('hidden');
  };

  // Dragging Logic
  let isDragging = false, dragStart = { x: 0, y: 0 };
  floatHeader.onmousedown = (e) => {
    isDragging = true;
    dragStart = { x: e.clientX - floatWin.offsetLeft, y: e.clientY - floatWin.offsetTop };
  };

  // Resizing Logic
  let isResizing = false;
  floatResizer.onmousedown = (e) => {
    isResizing = true;
    e.preventDefault();
  };

  window.addEventListener('mousemove', (e) => {
    if (isDragging) {
      floatWin.style.left = `${e.clientX - dragStart.x}px`;
      floatWin.style.top = `${e.clientY - dragStart.y}px`;
    }
    
    if (isResizing) {
      // 1. Calculate the intended new size
      let newWidth = e.clientX - floatWin.offsetLeft;
      let newHeight = e.clientY - floatWin.offsetTop;

      // 3. Clamp the values
      newWidth = Math.max(minW, Math.min(newWidth, maxW));
      newHeight = Math.max(minH, Math.min(newHeight, maxH));

      // 4. Apply to the element
      floatWin.style.width = `${newWidth}px`;
      floatWin.style.height = `${newHeight}px`;
    }
  });

  window.addEventListener('mouseup', () => {
    isDragging = false;
    isResizing = false;
  });

  function findTemporallyClosestWatch(targetMs) {
    if (!watches || !watches.length) return null;

    let closest = null;
    let minDiff = Infinity;

    for (const w of watches) {
      const diff = Math.abs(w.t - targetMs);
      if (diff < minDiff) {
        minDiff = diff;
        closest = w;
      }
    }
    return { watch: closest, diffMs: minDiff };
  }

  // Data Update Function
  function updateFloatingInfo(pose, idx) {
    if (floatWin.hidden) {
      document.getElementById('fx').textContent = "‚Äî";
      document.getElementById('fy').textContent = "‚Äî";
      document.getElementById('ft').textContent = "‚Äî";
      document.getElementById('ftime').textContent = "‚Äî";
      document.getElementById('favg').textContent = "‚Äî";
      document.getElementById('flv').textContent = "‚Äî";
      document.getElementById('frv').textContent = "‚Äî";
      document.getElementById('fcount').textContent = "Point: ‚Äî/‚Äî";
      return;
    }

    document.getElementById('fx').textContent = fmtNum(pose.x, 2);
    document.getElementById('fy').textContent = fmtNum(pose.y, 2);
    document.getElementById('ft').textContent = fmtNum(pose.theta, 2) + "¬∞";
    document.getElementById('ftime').textContent = fmtNum(pose.t / 1000, 2) + "s";
    
    const l = pose.l_vel || 0;
    const r = pose.r_vel || 0;
    
    document.getElementById('favg').textContent = fmtNum((l + r) / 2, 2);
    document.getElementById('flv').textContent = fmtNum(l, 2);
    document.getElementById('frv').textContent = fmtNum(r, 2);
    
    document.getElementById('fcount').textContent = `Point: ${idx + 1}/${rawPoses.length}`;

    // Waypoint info
    const result = findTemporallyClosestWatch(pose.t);
    const waypointTime = document.getElementById('fwatchtime');
    const waypointLabel = document.getElementById('fwatchlabel');
    const waypointValue = document.getElementById('fwatchvalue');
    const clickable = document.getElementById('fwatchclickable');
    const deltaTime = document.getElementById('fdeltat');

    if (result) {
      const { watch, diffMs } = result;
      const direction = (watch.t > pose.t) ? "ahead" : "ago";
      const seconds = (diffMs / 1000).toFixed(1);

      // Display the label and the time offset
      waypointLabel.textContent = ` ${watch.label}`;
      waypointValue.textContent = ` ${watch.value}`;
      waypointTime.textContent = ` ${seconds}s ${direction}`;
      
      // Clicking the readout jumps exactly to that waypoint
      clickable.style.cursor = "pointer";
      clickable.onclick = () => {
        playTimeMs = watch.t;
        selectedIndex = findFloorIndexByTime(watch.t);
        updatePoseReadout();
        requestDrawAll();
      };

      if (!data || !rawPoses.length) temp.textContent = "‚Äî";
      const lockedTime = rawPoses[selectedIndex]?.t || 0;
    
      // hoverTimelineTime is the time currently under the cursor
      const hoveredTime = hoverTimelineTime !== null ? hoverTimelineTime : lockedTime;
      const delta = Math.abs(hoveredTime - lockedTime) / 1000;
      deltaTime.textContent = `${delta.toFixed(2)}s`;
    } else {
      waypointLabel.textContent = " ‚Äî";
      waypointValue.textContent = " ‚Äî";
      waypointTime.textContent = " ‚Äî";
      deltaTime.textContent = "‚Äî";
      clickable.style.cursor = "default";
      clickable.onclick = null;
    }
  }

  // -------- pose readout --------
  function updatePoseReadout() {
    if (!data || !rawPoses.length) {
      timePill.textContent = "Time: ‚Äî";
      pointPill.textContent = "Point: ‚Äî/‚Äî";
      posePill.textContent = "X: ‚Äî  Y: ‚Äî Œ∏: ‚Äî  Speed: ‚Äî";
      return;
    }

    let idx = selectedIndex;
    let t = rawPoses[idx]?.t ?? null;
    let p = null;
  if (playing) {
    t = playTimeMs;
    idx = findFloorIndexByTime(playTimeMs);
    p = interpolatePoseAtTime(playTimeMs);

  } else if (hoverTimelineTime != null) {
    t = hoverTimelineTime;
    idx = findFloorIndexByTime(hoverTimelineTime);
    p = interpolatePoseAtTime(hoverTimelineTime);

  } else if (!playing && !trackLockActive && trackHover?.pose) {
    // if hover pose has a time, use interpolation (smooth) instead of the raw cached pose (snappy)
    const ht = trackHover.pose.t ?? null;

    if (ht != null) {
      t = ht;
      idx = findFloorIndexByTime(ht);
      p = interpolatePoseAtTime(ht);
    } else {
      // fallback to old behavior if hover time isn't available
      p = trackHover.pose;
      idx = trackHover.idxNearest ?? selectedIndex;
      t = rawPoses[idx]?.t ?? null;
    }

  } else if (!playing && trackLockActive && trackLockPose) {
    p = trackLockPose;
    idx = trackLockIndex ?? selectedIndex;
    t = rawPoses[idx]?.t ?? null;

  } else {
    p = poseToInches(rawPoses[idx]);
  }

    const total = rawPoses.length;
    timePill.textContent = (t == null) ? "Time: ‚Äî" : `Time: ${(t / 1000).toFixed(2)}s`;
    pointPill.textContent = `Point: ${Math.max(1, idx+1)}/${total}`;

    const spRaw = (p?.speed_raw != null) ? p.speed_raw : (rawPoses[idx]?.speed_raw ?? null);
    const spNorm = (p?.speed_norm != null) ? p.speed_norm : (rawPoses[idx]?.speed_norm ?? 0);

    posePill.textContent = p
      ? `X: ${fmtNum(p.x,1)}  Y: ${fmtNum(p.y,1)}  Œ∏: ${fmtNum(p.theta,1)}¬∞  Speed: ${fmtNum(spRaw,2)}`
      : "X: ‚Äî  Y: ‚Äî  Œ∏: ‚Äî  Speed: ‚Äî";
    updateDeltaReadout();
    updateFloatingInfo(p, idx);  
  }

  // -------- fit --------
  function fitToPoses() {
    const poses = getPosesInches();
    if (!poses.length) return;
    let minX = poses[0].x, maxX = poses[0].x;
    let minY = poses[0].y, maxY = poses[0].y;
    for (const p of poses) {
      minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
      minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
    }
    const margin = 6;
    bounds.minX = minX - margin; bounds.maxX = maxX + margin;
    bounds.minY = minY - margin; bounds.maxY = maxY + margin;
    bounds.pad = FIELD_BOUNDS_IN.pad;
    computeTransform();
    requestDrawAll();
  }

  // -------- view controls (square maximize + pan/zoom) --------
  function resetView() {
    viewZoom = 1;
    viewPanXpx = 0;
    viewPanYpx = 0;
  }

  function updateFieldLayout(preserveBounds=false) {
    const wrap = document.getElementById('canvasWrap');
    const rect = wrap.getBoundingClientRect();
    canvas.style.position = '';
    canvas.style.left = '';
    canvas.style.top = '';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    if (!preserveBounds) {
      bounds = { ...FIELD_BOUNDS_IN };
      bounds.pad = FIELD_BOUNDS_IN.pad;
    }

    resizeCanvas();
    computeTransform();
    requestDrawAll();
  }

  function resetFieldPosition() {
    resetView();
    updateFieldLayout(false); // sets full-field bounds + square layout
    btnFit.textContent = '‚§¢';
    btnFit.title = 'Recenter field (square)';
  }

  function clampZoom(z) {
    return clamp(z, CANVAS_ZOOM_MIN, CANVAS_ZOOM_MAX);
  }

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // world point under cursor (inches)
    const w0 = screenToWorld(mx, my);

    const delta = (e.deltaY || 0);
    const zoomFactor = Math.exp(-delta * 0.0012);
    const newZoom = clampZoom(viewZoom * zoomFactor);

    viewZoom = newZoom;

    // adjust pan so (w0) stays under cursor
    // mx = w0.x*scale + offsetXpx, with scale/offset based on base*viewZoom and viewPan*
    const newScale = baseScale * viewZoom;
    const newOffXBase = baseOffsetXpx * viewZoom;
    const newOffYBase = baseOffsetYpx * viewZoom;

    viewPanXpx = mx - (w0.x * newScale + newOffXBase);
    viewPanYpx = my - (newOffYBase - w0.y * newScale);

    computeTransform();
    requestDrawAll();
  }, { passive:false });

  canvas.addEventListener('pointerdown', (e) => {
    if (e.button !== 0) return; // left only

    // Arm panning on any press. If this turns into a drag, we pan the view.
    // If it remains a click (little/no movement), existing click logic selects watches/track points.
    panArmed = true;
    isPanning = false;
    suppressNextClick = false;
    panPointerId = e.pointerId;

    const rect = canvas.getBoundingClientRect();
    panStart.x = e.clientX - rect.left;
    panStart.y = e.clientY - rect.top;
    panStart.panX = viewPanXpx;
    panStart.panY = viewPanYpx;

    canvas.setPointerCapture(e.pointerId);
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!panArmed) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const dx = x - panStart.x;
    const dy = y - panStart.y;

    // Only start panning once the user has clearly dragged.
    if (!isPanning) {
      if (Math.abs(dx) + Math.abs(dy) <= 3) return;
      isPanning = true;
      suppressNextClick = true; // prevent 'click' selection after a drag-pan
      canvas.style.cursor = 'grabbing';

      // If a hover-preview was active, clear it so the view feels stable while panning.
      if (!trackLockActive && trackHover) {
        clearTrackHover(true);
        highlightPoseInList();
        updatePoseReadout();
      }
    }

    viewPanXpx = panStart.panX + dx;
    viewPanYpx = panStart.panY + dy;

    computeTransform();
    requestDrawAll();
  });

  function endPan(e) {
    if (!panArmed) return;
    panArmed = false;
    isPanning = false;
    canvas.style.cursor = '';
    try { canvas.releasePointerCapture(panPointerId ?? e.pointerId); } catch {}
    panPointerId = null;
  }

  canvas.addEventListener('pointerup', endPan);
  canvas.addEventListener('pointercancel', endPan);

  // -------- track hover/lock --------
  function pickTrackPose(clientX, clientY) {
    if (!rawPoses.length) return null;
    const rect = canvas.getBoundingClientRect();
    const mx = clientX - rect.left;
    const my = clientY - rect.top;

    const poses = getPosesInches();
    if (poses.length < 2) return null;

    let best = { dist2: Infinity, i: -1, alpha: 0 };

    for (let i = 0; i < poses.length - 1; i++) {
      const a = poses[i], b = poses[i+1];
      const pa = worldToScreen(a.x, a.y);
      const pb = worldToScreen(b.x, b.y);

      const vx = pb.x - pa.x, vy = pb.y - pa.y;
      const wx = mx - pa.x, wy = my - pa.y;
      const vv = vx*vx + vy*vy || 1;
      let alpha = (wx*vx + wy*vy) / vv;
      alpha = clamp(alpha, 0, 1);

      const px = pa.x + alpha*vx;
      const py = pa.y + alpha*vy;
      const dx = mx - px, dy = my - py;
      const d2 = dx*dx + dy*dy;

      if (d2 < best.dist2) best = { dist2: d2, i, alpha };
    }

    const dist = Math.sqrt(best.dist2);
    if (dist > HOVER_PIXEL_TOL + TRACK_HOVER_PAD_PX) return null;
    
    const i0 = best.i, i1 = best.i + 1;
    const p0 = poses[i0], p1 = poses[i1];
    const a = best.alpha;

    // NEW: compute interpolated time from rawPoses (not the inches-converted array)
    const rt0 = rawPoses[i0]?.t ?? 0;
    const rt1 = rawPoses[i1]?.t ?? rt0;
    const tMs = rt0 + a * (rt1 - rt0);

    const pose = {
      t: tMs, // <-- was null
      x: p0.x + (p1.x - p0.x) * a,
      y: p0.y + (p1.y - p0.y) * a,
      theta: angLerpDeg(p0.theta ?? 0, p1.theta ?? 0, a),
      l_vel: (p0.l_vel ?? 0) + ((p1.l_vel ?? 0) - (p0.l_vel ?? 0)) * a,
      r_vel: (p0.r_vel ?? 0) + ((p1.r_vel ?? 0) - (p0.r_vel ?? 0)) * a,
      speed_raw: (p0.speed_raw ?? 0) + ((p1.speed_raw ?? 0) - (p0.speed_raw ?? 0)) * a,
      speed_norm: (p0.speed_norm ?? 0) + ((p1.speed_norm ?? 0) - (p0.speed_norm ?? 0)) * a,
    };

    // nearest index can stay if you still want it for list highlighting
    const nearestIdx = (a < 0.5) ? i0 : i1;
    return { pose, nearestIdx };
  }

  function clearTrackHover(restore) {
    trackHover = null;
    if (restore && trackHoverSavedIndex != null) {
      selectedIndex = trackHoverSavedIndex;
      trackHoverSavedIndex = null;
    }
  }

  function clearTrackLock() {
    trackLockActive = false;
    trackLockPose = null;
    trackLockIndex = null;
  }

  // -------- watch hit test on field --------
  function hitTestWatchAtClient(clientX, clientY) {
    if (!watchMarkers.length) return null;
    const rect = canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    const tol = 10;
    let best = null;
    let bestD2 = tol*tol;
    for (const m of watchMarkers) {
      if (!m.pose) continue;
      const p = worldToScreen(m.pose.x, m.pose.y);
      const dx = p.x - x;
      const dy = p.y - y;
      const d2 = dx*dx + dy*dy;
      if (d2 <= bestD2) { bestD2 = d2; best = m; }
    }
    return best;
  }

  // -------- playback --------
  let playPose = null;

  function pause() {
    playing = false;
    btnPlay.textContent = "‚ñ∂";
    if (raf) cancelAnimationFrame(raf);
    raf = null;
    playPose = null;
    lastWall = null;
    setStatus(`Paused at time ${((rawPoses[selectedIndex]?.t ?? 0)/1000).toFixed(2)}s`);
  }

  function play() {
    if (!rawPoses.length) return;
    if (window.__live && window.__live.streaming) { setStatus('Playback disabled while livestreaming.'); return; }

    // starting playback clears track lock to avoid confusing states
    clearTrackHover(true);
    clearTrackLock();
    selectedWatch = null;
    timelineHoverSaved = null;
    setStatus(`Playing from time ${((rawPoses[selectedIndex]?.t ?? 0)/1000).toFixed(2)}s`);

    const tStart = rawPoses[selectedIndex]?.t;
    playTimeMs = (typeof tStart === "number") ? tStart : (rawPoses[0]?.t ?? 0);

    playing = true;
    btnPlay.textContent = "‚è∏";
    lastWall = performance.now();

    const tick = (now) => {
      if (!playing) return;
      const dtWall = now - lastWall;
      lastWall = now;
      // Make playback speed match the heat color scale (slow=red, fast=green),
      // including when the user adjusts Min/Max speed normalization.
      const cur = interpolatePoseAtTime(playTimeMs) || rawPoses[selectedIndex] || null;
      const n = (cur && typeof cur.speed_norm === "number") ? cur.speed_norm : 0.5;
      const SPEED_SLOW = 0.25; // red end
      const SPEED_FAST = 2.00; // green end
      playTimeMs += dtWall * playRate;

      const tMin = rawPoses[0]?.t ?? 0;
      const tMax = rawPoses[rawPoses.length - 1]?.t ?? tMin;

      if (playTimeMs >= tMax) {
        playTimeMs = tMax;
        playPose = interpolatePoseAtTime(playTimeMs);
        selectedIndex = rawPoses.length - 1;
        updatePoseReadout();
        requestDrawAll();
        pause();
        return;
      }

      playPose = interpolatePoseAtTime(playTimeMs);
      selectedIndex = findFloorIndexByTime(playTimeMs);

      // Auto-open Watches and highlight the most recent watch hit
      const last = lastWatchAtTime(playTimeMs);
      if (last && (!selectedWatch || selectedWatch.marker?.t !== last.t)) {
        selectedWatch = { marker: last };
        // open Watches panel during playback
        if (secWatches) secWatches.open = true;
        highlightWatchInList(last.t, false);
      }

      updatePoseReadout();
      requestDrawAll();
      raf = requestAnimationFrame(tick);
    };

    raf = requestAnimationFrame(tick);
  }

  // -------- timeline interactions --------
  function timelineMousePos(e) {
    const rect = timelineCanvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  timelineCanvas.addEventListener("mousemove", (e) => {
    if (!data || playing || !rawPoses.length) return;

    const { x, y } = timelineMousePos(e);
    const hit = timelinePickWatchDot(x, y);
    timelineCanvas.style.cursor = hit ? "pointer" : "crosshair";

    if (timelineHoverSaved == null) {
      timelineHoverSaved = {
        index: selectedIndex,
        lockActive: trackLockActive,
        lockPose: trackLockPose,
        lockIndex: trackLockIndex
      };
    }

    // timeline hover always previews, even if track lock is active
    hoverTimelineTime = xToTime(x);
    updatePoseReadout();
    requestDrawAll();
  });

  timelineCanvas.addEventListener("mouseleave", () => {
    if (!data || playing) return;
    hoverTimelineTime = null;
    timelineCanvas.style.cursor = "default";

    if (timelineHoverSaved != null) {
      selectedIndex = timelineHoverSaved.index;
      trackLockActive = timelineHoverSaved.lockActive;
      trackLockPose = timelineHoverSaved.lockPose;
      trackLockIndex = timelineHoverSaved.lockIndex;
      timelineHoverSaved = null;
    }

    updatePoseReadout();
    requestDrawAll();
  });

  timelineCanvas.addEventListener("mousedown", (e) => {
    if (!data || playing || !rawPoses.length) return;
    if (window.__live && window.__live.streaming) return;
    const { x, y } = timelineMousePos(e);

    const hit = timelinePickWatchDot(x, y);
    if (hit) {
      selectWatchMarker(hit, true, { x: e.clientX, y: e.clientY });
      return;
    }

    // lock selection at time (clears track lock)
    clearTrackHover(true);
    clearTrackLock();
    if (selectedWatch == null) {
      setStatus(`Unlocked track lock.`);
    }
    selectedWatch = null;


    const t = xToTime(x);
    selectedIndex = findFloorIndexByTime(t);
    hoverTimelineTime = null;
    timelineHoverSaved = null;

    highlightPoseInList();
    updatePoseReadout();
    requestDrawAll();
  });

  // -------- field interactions --------
  canvas.addEventListener('mousemove', (e) => {
    if (!data || playing || isPanning) return;

    // watch hover has priority
    const hw = hitTestWatchAtClient(e.clientX, e.clientY);
    if (hw) {
      hoverWatch = hw;
      canvas.style.cursor = "pointer";
      requestDrawAll();
      return;
    } else {
      if (hoverWatch) { hoverWatch = null; requestDrawAll(); }
      canvas.style.cursor = "";
    }

    // if locked, ignore hover preview
    if (trackLockActive) return;

    const hit = pickTrackPose(e.clientX, e.clientY);

    if (!hit) {
      // no field hit => remove timeline hover preview too
      hoverTimelineTime = null;

      if (trackHover) {
        clearTrackHover(true);
        highlightPoseInList();
        updatePoseReadout();
        requestDrawAll();
      }
      return;
    }

    if (trackHoverSavedIndex == null) trackHoverSavedIndex = selectedIndex;
    trackHover = { t: hit.pose.t, idxNearest: hit.nearestIdx };

    // Drive the timeline grey line from the hovered field pose
    hoverTimelineTime = hit.pose.t ?? null;

    updatePoseReadout();
    requestDrawAll();
  });

  canvas.addEventListener('mouseleave', () => {
    hoverWatch = null;
    // ensure timeline hover preview can't 'stick'
    hoverTimelineTime = null;
    timelineHoverSaved = null;
    canvas.style.cursor = "";
    if (!trackLockActive && trackHover) {
      clearTrackHover(true);
      highlightPoseInList();
      updatePoseReadout();
      requestDrawAll();
    }
  });

  canvas.addEventListener('click', (e) => {
    if (!data || playing) return;
    if (window.__live && window.__live.streaming) return;
    if (suppressNextClick) { suppressNextClick = false; return; }

    const hw = hitTestWatchAtClient(e.clientX, e.clientY);
    if (hw) {
      selectWatchMarker(hw, true, { x: e.clientX, y: e.clientY });
      return;
    }

    const hit = pickTrackPose(e.clientX, e.clientY);
    if (hit) {
      // lock to clicked position
      pause();
      selectedWatch = null;

      trackLockActive = true;
      trackLockPose = hit.pose;
      trackLockIndex = hit.nearestIdx;

      selectedIndex = hit.nearestIdx;
      clearTrackHover(false);
      trackHoverSavedIndex = null;

      // Show locked pos on timeline
      if (timelineHoverSaved == null) {
        timelineHoverSaved = {
          index: selectedIndex,
          lockActive: trackLockActive,
          lockPose: hit.pose,
          lockIndex: trackLockIndex
        };
      }

      setStatus(`Locked to track near pose #${selectedIndex+1}. (Click off-track to unlock)`);
      highlightPoseInList();
      updatePoseReadout();
      requestDrawAll();
      return;
    }

    // click off-track unlocks
    if (trackLockActive) {
      clearTrackLock();
      setStatus(`Unlocked track lock.`);
      updatePoseReadout();
      requestDrawAll();
    }
  });

  
  // -------- Left sidebar controls (Stop / Connect / Refresh) --------
  // Live streaming model:
  // - Connect toggles the WebSocket connection (/ws)
  // - Start/Stop is the existing "Stop" button (it becomes a toggle)
  //   * When disconnected: disabled, tooltip "Starts streaming. Connect to start."
  //   * When connected & idle: shows "Start"
  //   * When streaming: shows "Stop"
  //   * Cmd/Ctrl + click Stop => force kill (/api/kill), if server supports it
  //
  // Output always appends into #liveWin.

  const liveWinEl = document.getElementById('liveWin');
  const btnLeftStopEl = document.getElementById('btnLeftStop');
  const btnLeftConnectEl = document.getElementById('btnLeftConnect');
  const btnLeftRefreshEl = document.getElementById('btnLeftRefresh');
  const leftRefreshIntervalEl = document.getElementById('leftRefreshInterval');

  let leftWs = null;
  let leftConnected = false;
  let leftStreaming = false;

  // In livestream mode, optionally keep the robot snapped to the newest pose when not hovering the timeline.
  // Toggled with Space (while connected).
  let liveAutoFollowHead = true;

  let leftRefreshTimer = null;
  let leftRefreshMs = parseInt(leftRefreshIntervalEl?.value || "500", 10) || 500;

  // --- Live incremental processing ---
  // Buffer incoming WS lines; doLeftRefresh consumes them and updates poses/watches.
  let livePendingLines = [];
  let livePendingConsumed = 0; // index into livePendingLines

  // Track how much we've already integrated into rawPoses/watches
  let liveLastPoseT = null; // last pose timestamp integrated
  let liveLastPoseCount = 0;
  let liveLastWatchCount = 0;

  function parseLiveLineIntoState(line) {
    const s = stripToTag(line);
    if (!s) return { posesAdded: 0, watchesAdded: 0 };

    // DATA: [DATA],millis,x,y,theta,l_vel,r_vel
    if (s.startsWith("[DATA],")) {
      const parts = s.split(",");
      if (parts.length < 7) return { posesAdded: 0, watchesAdded: 0 };
      const t = toNumMaybe(parts[1]);
      const x = toNumMaybe(parts[2]);
      const y = toNumMaybe(parts[3]);
      const theta = toNumMaybe(parts[4]);
      const l_vel = toNumMaybe(parts[5]);
      const r_vel = toNumMaybe(parts[6]);
      if (t == null || x == null || y == null) return { posesAdded: 0, watchesAdded: 0 };

      // De-dup / monotonic guard (common if stream repeats)
      if (liveLastPoseT != null && t <= liveLastPoseT) return { posesAdded: 0, watchesAdded: 0 };

      // Derive a "speed" (raw) from wheel velocities if present
      const lv = (typeof l_vel === "number" && isFinite(l_vel)) ? l_vel : 0;
      const rv = (typeof r_vel === "number" && isFinite(r_vel)) ? r_vel : 0;
      const speed_raw = (Math.abs(lv) + Math.abs(rv)) / 2;

      rawPoses.push({
        t, x, y,
        theta: (theta == null) ? 0 : theta,
        l_vel: (l_vel == null) ? null : l_vel,
        r_vel: (r_vel == null) ? null : r_vel,
        speed_raw,
        speed_norm: 0,
      });
      liveLastPoseT = t;
      return { posesAdded: 1, watchesAdded: 0 };
    }

    // WATCH: [WATCH],millis,level,label,value (value may contain commas)
    if (s.startsWith("[WATCH],")) {
      const parts = s.split(",");
      if (parts.length < 5) return { posesAdded: 0, watchesAdded: 0 };
      const t = toNumMaybe(parts[1]);
      if (t == null) return { posesAdded: 0, watchesAdded: 0 };
      const level = parts[2] ?? "INFO";
      const label = parts[3] ?? "";
      const value = parts.slice(4).join(",");
      watches.push({ t, level, label, value });
      return { posesAdded: 0, watchesAdded: 1 };
    }

    return { posesAdded: 0, watchesAdded: 0 };
  }

  function liveAppendLine(s) {
    if (!liveWinEl) return;
    const trimmed = (s.endsWith("\n") || s.endsWith("\r\n")) ? s : (s + "\n");
    // keep it responsive (basic cap)
    const MAX_CHARS = 200_000;
    if (liveWinEl.value.length > MAX_CHARS) {
      liveWinEl.value = liveWinEl.value.slice(liveWinEl.value.length - MAX_CHARS);
    }
    const nearBottom =
      (liveWinEl.scrollTop + liveWinEl.clientHeight >= liveWinEl.scrollHeight - 12);

    // append + keep last ~2000 lines for perf
    liveWinEl.value += trimmed;
    const lines = liveWinEl.value.split("\n");
    const MAX = 2000;
    if (lines.length > MAX) liveWinEl.value = lines.slice(lines.length - MAX).join("\n");

    // only autoscroll if user was already at bottom
    if (nearBottom) liveWinEl.scrollTop = liveWinEl.scrollHeight;
  }

  function stripToTag(line) {
    // Accept library-prefixed lines like: "[28.08] [INFO]: [DATA],..."
    const iData = line.indexOf('[DATA]');
    const iWatch = line.indexOf('[WATCH]');
    let i = -1;
    if (iData >= 0 && iWatch >= 0) i = Math.min(iData, iWatch);
    else i = (iData >= 0) ? iData : iWatch;

    if (i < 0) return "";
    return line.slice(i).trim();
  }

  function setLeftUi() {
    if (btnLeftConnect) {
      btnLeftConnect.classList.toggle('isOn', leftConnected);
      btnLeftConnect.textContent = leftConnected ? "Disconnect" : "Connect";
    }

    if (btnLeftStop) {
      btnLeftStop.disabled = !leftConnected;
      if (!leftConnected) {
        btnLeftStop.title = "Starts streaming. Connect to start.";
        btnLeftStop.textContent = "Start";
        btnLeftStop.classList.remove('isOn');
      } else {
        btnLeftStop.title = leftStreaming
          ? "Stop streaming. Cmd/Ctrl+Click to force kill."
          : "Starts streaming.";
        btnLeftStop.textContent = leftStreaming ? "Stop" : "Start";
        btnLeftStop.classList.toggle('isOn', leftStreaming);
      }
    }
  }

  function leftSetUI(reason) {
    setLeftUi();
    if (window.__live) { window.__live.connected = !!leftConnected; window.__live.streaming = !!leftStreaming; }
    // Connect button state
    if (btnLeftConnectEl) {
      btnLeftConnectEl.classList.toggle('isOn', !!leftConnected);
      btnLeftConnectEl.title = leftConnected ? "Disconnect" : "Connect";
    }

    // Start/Stop toggle state (this is btnLeftStop)
    if (btnLeftStopEl) {
      btnLeftStopEl.textContent = leftStreaming ? "Stop" : "Start";
      btnLeftStopEl.disabled = !leftConnected;
      btnLeftStopEl.title = leftConnected
        ? (leftStreaming ? "Stop streaming" : "Starts streaming.")
        : "Starts streaming. Connect to start.";
    }

    // Refresh controls only meaningful while connected
    if (btnLeftRefreshEl) btnLeftRefreshEl.disabled = !leftConnected;
    if (leftRefreshIntervalEl) leftRefreshIntervalEl.disabled = !leftConnected;

    // Optional: write small state message to live window when transitions happen
    if (reason) {
      liveAppendLine(`[UI] ${reason}`);
    }
  }

  function wsUrl(path) {
    const isHttps = window.location.protocol === "https:";
    const proto = isHttps ? "wss:" : "ws:";
    return `${proto}//${window.location.host}${path}`;
  }

  async function apiPost(path) {
    const res = await fetch(path, { method: "POST" });
    // Best-effort JSON; don't crash UI if server returns non-JSON or 404
    let json = null;
    try { json = await res.json(); } catch (e) {}
    return { ok: res.ok, status: res.status, json };
  }

  function connectLeft() {
    stopStreaming(false, false);
    if (leftWs) return;
    const url = wsUrl("/ws");
    leftWs = new WebSocket(url);

    leftWs.addEventListener("open", () => {
      leftConnected = true;
      leftSetUI("Connected");

      startLeftRefresh();
    });

    leftWs.addEventListener("message", (ev) => {
      const raw = (typeof ev.data === "string") ? ev.data : "";
      const trimmed = stripToTag(raw);
      if (trimmed) {
        liveAppendLine(trimmed);
        livePendingLines.push(trimmed);
        // cap pending buffer to avoid unbounded growth
        const MAX_PENDING = 20000;
        if (livePendingLines.length > MAX_PENDING) {
          const drop = livePendingLines.length - MAX_PENDING;
          livePendingLines.splice(0, drop);
          livePendingConsumed = Math.max(0, livePendingConsumed - drop);
        }
      }
    });

    leftWs.addEventListener("close", () => {
      leftWs = null;
      leftConnected = false;
      leftStreaming = false;
      if (window.__live) { window.__live.connected = false; window.__live.streaming = false; }
      stopLeftRefresh();
      leftSetUI("Disconnected");
    });

    leftWs.addEventListener("error", () => {
      // Errors often precede close; keep it gentle.
      liveAppendLine("[WS] error");
    });

    leftSetUI("Connecting‚Ä¶");
  }

  function disconnectLeft() {
    if (leftWs) {
      try { leftWs.close(); } catch (e) {}
    }
    leftWs = null;
    leftConnected = false;
    leftStreaming = false;
    stopLeftRefresh();
    leftSetUI("Disconnected");
  }

  function stopLeftRefresh() {
    if (leftRefreshTimer) {
      clearInterval(leftRefreshTimer);
      leftRefreshTimer = null;
    }
  }

  function startLeftRefresh() {
    stopLeftRefresh();
    if (!leftConnected) return;
    if (!leftRefreshMs || leftRefreshMs <= 0) return;
    leftRefreshTimer = setInterval(() => {
      doLeftRefresh();
    }, leftRefreshMs);
  }

  let lastPoseIndex = 0;
  async function doLeftRefresh() {
    // During live mode, refresh means: integrate any pending WS lines into
    // rawPoses/watches, then update derived state and redraw.
    if (!leftConnected) return;
    if (!leftStreaming) return; // "Stop" pauses drawing; we still buffer lines

    if (!data) {
      data = { poses: [], watches: [], meta: {} };
    }

    const startIdx = livePendingConsumed;
    const endIdx = livePendingLines.length;
    if (startIdx >= endIdx) {
      // Nothing new; still ensure we snap to latest if appropriate
      if (liveAutoFollowHead && rawPoses.length && hoverTimelineTime == null && !playing && !trackLockActive && !(trackHover && (trackHover.pose || trackHover.t))) {
        selectedIndex = rawPoses.length - 1;
        lastPoseIndex = selectedIndex;
        updatePoseReadout();
        requestDrawAll();
      } else if (!liveAutoFollowHead && rawPoses.length && hoverTimelineTime == null && !playing && !trackLockActive && !(trackHover && (trackHover.pose || trackHover.t))) {
        selectedIndex = lastPoseIndex;
      }
      return;
    }

    let posesAdded = 0;
    let watchesAdded = 0;

    for (let i = startIdx; i < endIdx; i++) {
      const r = parseLiveLineIntoState(livePendingLines[i]);
      posesAdded += r.posesAdded;
      watchesAdded += r.watchesAdded;
    }
    livePendingConsumed = endIdx;

    if (posesAdded === 0 && watchesAdded === 0) return;

    // Keep watches sorted (poses are appended monotonically by t)
    if (watchesAdded > 0) {
      watches.sort((a,b) => (a.t ?? 0) - (b.t ?? 0));
    }

    // Recompute derived fields. This is cheap at your scale (<~4000 poses).
    computeSpeedNorm();

    if (watchesAdded > 0) {
      recomputeWatchMarkers();
      rebuildWatchMarkersByTime();
      renderWatchList();
    }

    if (posesAdded > 0) {
      renderPoseList();
      // If not hovering timeline/track, keep the robot on the most recent pose.
      if (liveAutoFollowHead && hoverTimelineTime == null && !playing && !trackLockActive && !(trackHover && (trackHover.pose || trackHover.t))) {
        selectedIndex = rawPoses.length - 1;
      } else if (!liveAutoFollowHead && rawPoses.length && hoverTimelineTime == null && !playing && !trackLockActive && !(trackHover && (trackHover.pose || trackHover.t))) {
        selectedIndex = lastPoseIndex;
      }
    }

    updatePoseReadout();
    requestDrawAll();
  }


  async function startStreaming() {
    const r = await apiPost("/api/start");
    if (!r.ok) {
      liveAppendLine(`[api] start failed (${r.status})`);
      return false;
    }
    leftStreaming = true;
    leftSetUI("Streaming started");
    return true;
  }

  async function stopStreaming(forceKill = false, doMsg = true) {
    const path = forceKill ? "/api/kill" : "/api/stop";
    const r = await apiPost(path);
    if (!r.ok) {
      liveAppendLine(`[api] stop/kill failed (${r.status})`);
      // Even if kill endpoint doesn't exist, still fall back to /api/stop
      if (forceKill && r.status === 404) {
        const r2 = await apiPost("/api/stop");
        if (!r2.ok) return false;
      } else {
        return false;
      }
    }
    leftStreaming = false;
    if (doMsg)
      leftSetUI(forceKill ? "Force-killed" : "Streaming stopped");
    return true;
  }

  // Connect toggle
  btnLeftConnectEl?.addEventListener('click', () => {
    if (leftConnected) disconnectLeft();
    else connectLeft();
  });

  // Start/Stop toggle (+ cmd/ctrl click => force kill)
  btnLeftStopEl?.addEventListener('click', async (e) => {
    if (!leftConnected) return;

    const forceKill = !!(e?.metaKey || e?.ctrlKey);
    if (forceKill) {
      await stopStreaming(true);
      return;
    }

    if (!leftStreaming) await startStreaming();
    else await stopStreaming(false);
    btnLeftConnectEl.title = leftConnected ? "Disconnect" : "Connect";
    setLeftUi();
  });

  // Manual refresh button
  btnLeftRefreshEl?.addEventListener('click', () => {
    doLeftRefresh();
  });

  leftRefreshIntervalEl?.addEventListener('change', () => {
    leftRefreshMs = parseInt(leftRefreshIntervalEl.value || "0", 10) || 0;
    startLeftRefresh();
  });

  // Initialize UI on load
  leftSetUI("");


// -------- splitters with collapse --------
  (function setupSplitters() {
    let draggingV = false;
    let startX = 0;
    let startW = 0;

    let lastRightSidebarW = 360;
    let lastLeftSidebarW = 360;
    // ensure grid state matches persisted widths on load
    try {
      if (getLeftSidebarW() <= 1) { leftEl.classList.add('isCollapsed'); rowGrid && rowGrid.classList.add('leftCollapsed'); }
    } catch (e) {}


    const getRightSidebarW = () => {
      const v = getComputedStyle(root).getPropertyValue('--rightSidebarW').trim();
      const n = parseFloat(v);
      return isFinite(n) ? n : 360;
    };
    const setRightSidebarW = (px) => {
      px = Math.min(px, MAX_SIDEBAR_W_PX);
      root.style.setProperty('--rightSidebarW', `${px}px`);

    }

    const getLeftSidebarW = () => {
      const v = getComputedStyle(root).getPropertyValue('--leftSidebarW').trim();
      const n = parseFloat(v);
      return isFinite(n) ? n : 360;
    };
    const setLeftSidebarW = (px) => {
      px = Math.min(px, MAX_PX_LIVEWIN);
      root.style.setProperty('--leftSidebarW', `${px}px`);
    };

    let draggingVL = false;
    let startXL = 0;
    let startWL = 0;

    vSplitL.addEventListener('mousedown', (e) => {
      draggingVL = true;
      startXL = e.clientX;
      startWL = getLeftSidebarW();
      document.body.style.cursor = 'col-resize';
      e.preventDefault();
    });

    vSplit.addEventListener('mousedown', (e) => {
      draggingV = true;
      startX = e.clientX;
      startW = getRightSidebarW();
      document.body.style.cursor = 'col-resize';
      e.preventDefault();
    });

    let draggingH = false;
    let startY = 0;
    let startH = 0;
    let lastTimelineH = 260;

    const getTimelineH = () => {
      const v = getComputedStyle(root).getPropertyValue('--timelineH').trim();
      const n = parseFloat(v);
      return isFinite(n) ? n : 260;
    };
    const setTimelineH = (px) => {
      px = Math.min(px, MAX_TIMELINE_H_PX);
      root.style.setProperty('--timelineH', `${px}px`);
    }

    hSplit.addEventListener('mousedown', (e) => {
      draggingH = true;
      startY = e.clientY;
      startH = getTimelineH();
      document.body.style.cursor = 'row-resize';
      e.preventDefault();

    });

    window.addEventListener('mousemove', (e) => {
      if (draggingVL) {
        const dx = e.clientX - startXL;
        const w = window.innerWidth;
        let next = clamp(startWL + dx, 0, Math.max(0, w - 240));

        if (next <= COLLAPSE_PX_LEFTSIDEBAR) {
          next = 0;
          leftEl.classList.add('isCollapsed');
          rowGrid && rowGrid.classList.add('leftCollapsed');
        } else {
          leftEl.classList.remove('isCollapsed');
          rowGrid && rowGrid.classList.remove('leftCollapsed');
          lastLeftSidebarW = next;
        }
        setLeftSidebarW(next);
        resizeCanvas();
        resizeTimeline();
      }

      if (draggingV) {
        const dx = e.clientX - startX;
        const w = window.innerWidth;
        let next = clamp(startW - dx, 0, Math.max(0, w - 240));

        if (next <= COLLAPSE_PX_SIDEBAR) {
          next = 0;
          rightEl.classList.add('isCollapsed');
        } else {
          rightEl.classList.remove('isCollapsed');
          lastRightSidebarW = next;
        }
        setRightSidebarW(next);
        resizeCanvas();
        resizeTimeline();
      }

      if (draggingH) {
        const dy = e.clientY - startY;
        const h = window.innerHeight;
        let next = clamp(startH - dy, 0, Math.max(0, Math.floor(h * 0.80)));

        if (next <= COLLAPSE_PX_TIMELINE) {
          next = 0;
          timelineBar.classList.add('isCollapsed');
        } else {
          timelineBar.classList.remove('isCollapsed');
          lastTimelineH = next;
        }

        setTimelineH(next);
        resizeTimeline();
        resizeCanvas();
      }
    });

    window.addEventListener('mouseup', () => {
      if (draggingV || draggingH || draggingVL) {
        draggingV = false;
        draggingH = false;
        draggingVL = false;
        document.body.style.cursor = '';
        // If user re-expands from collapsed by dragging, restore visibility automatically
        if (getRightSidebarW() > COLLAPSE_PX_SIDEBAR) rightEl.classList.remove('isCollapsed');
        if (getTimelineH() > COLLAPSE_PX_TIMELINE) timelineBar.classList.remove('isCollapsed');
        resizeCanvas();
        resizeTimeline();
      }
    });

    // double-click splitters to toggle collapse/restore
    vSplitL.addEventListener('dblclick', () => {
      if (!DBLCLICK_COLLAPSE_LEFTSIDEBAR) return;
      const cur = getLeftSidebarW();
      if (cur <= COLLAPSE_PX_LEFTSIDEBAR) {
        setLeftSidebarW(Math.max(1, lastLeftSidebarW));
        leftEl.classList.remove('isCollapsed');
        rowGrid && rowGrid.classList.remove('leftCollapsed');
      } else {
        lastLeftSidebarW = cur;
        setLeftSidebarW(0);
        leftEl.classList.add('isCollapsed');
        rowGrid && rowGrid.classList.add('leftCollapsed');
      }
      resizeCanvas();
      resizeTimeline();
    });

    vSplit.addEventListener('dblclick', () => {
      const cur = getRightSidebarW();
      if (cur <= COLLAPSE_PX_SIDEBAR) {
        setRightSidebarW(Math.max(1, lastRightSidebarW));
        rightEl.classList.remove('isCollapsed');
      } else {
        lastRightSidebarW = cur;
        setRightSidebarW(0);
        rightEl.classList.add('isCollapsed');
      }
        resetFieldPosition();
        resizeCanvas();
        layoutTimelineCanvas();
    });

    hSplit.addEventListener('dblclick', () => {
      const cur = getTimelineH();
      let next = getTimelineH();
      if (cur <= COLLAPSE_PX_TIMELINE) {
        setTimelineH(Math.max(160, lastTimelineH));
        timelineBar.classList.remove('isCollapsed');
      } else {
        lastTimelineH = cur;
        setTimelineH(0);
        timelineBar.classList.add('isCollapsed');
      }
        next = Math.min(1, next);
        setTimelineH(next);
        resetFieldPosition();
        drawField();
        resizeTimeline();
        resizeCanvas();
        layoutTimelineCanvas();
    });
  })();

  // -------- data load --------
  function setData(obj) {
    data = obj;'lu'
    if (!obj || !Array.isArray(obj.poses)) {
      setStatus("Invalid viewer JSON: missing poses[]");
      return;
    }

    rawPoses = obj.poses
      .filter(p => p && typeof p.x === "number" && typeof p.y === "number")
      .map(p => ({
        t: (typeof p.t === "number") ? p.t : (toNumMaybe(p.t) ?? null),
        x: p.x, y: p.y,
        theta: (typeof p.theta === "number") ? p.theta : (toNumMaybe(p.theta) ?? 0),
        l_vel: (typeof p.l_vel === "number") ? p.l_vel : (toNumMaybe(p.l_vel) ?? null),
        r_vel: (typeof p.r_vel === "number") ? p.r_vel : (toNumMaybe(p.r_vel) ?? null),
        speed_raw: (typeof p.speed === "number") ? p.speed : (toNumMaybe(p.speed) ?? 0),
        speed_norm: 0,
      }))
      .sort((a,b) => (a.t ?? 0) - (b.t ?? 0));

    // watches: accept alternate key just in case
    watches = normalizeWatches(obj.watches || obj.watch || obj.events || []);

    const inferred = inferUnitsFromMeta(obj?.meta?.units);
    unitsSelect.value = inferred;
    setUnitsFactorFromSelect(inferred);

    const rw = obj?.meta?.robot?.width;
    const rh = obj?.meta?.robot?.height;
    robotWEl.value = (typeof rw === "number" && isFinite(rw)) ? String(rw) : "12";
    robotHEl.value = (typeof rh === "number" && isFinite(rh)) ? String(rh) : "12";

    const mx = toNumMaybe(obj?.meta?.offset_x);
    const my = toNumMaybe(obj?.meta?.offset_y);
    const mt = toNumMaybe(obj?.meta?.offset_theta);

    offXEl.value = (typeof mx === "number" && isFinite(mx)) ? String(clamp(mx, -OFFSET_MAX, OFFSET_MAX)) : "0";
    offYEl.value = (typeof my === "number" && isFinite(my)) ? String(clamp(my, -OFFSET_MAX, OFFSET_MAX)) : "0";
    offThetaEl.value = (typeof mt === "number" && isFinite(mt)) ? String(clamp(mt, -OFFSET_MAX, OFFSET_MAX)) : "0";
    updateOffsetsFromInputs();

    computeSpeedNorm();

    fmt.textContent = `v${obj.version ?? "?"}`;

    selectedWatch = null;
    selectedIndex = 0;
    hoverTimelineTime = null;
    timelineHoverSaved = null;
    hoverWatch = null;

    clearTrackHover(true);
    clearTrackLock();
    pause();

    recomputeWatchMarkers();
    rebuildWatchMarkersByTime();
    renderWatchList();
    renderPoseList();

    // stats
    const statsHint = document.getElementById('statsMarker');
    const th = obj.thinning || {};
    const t0 = rawPoses[0]?.t;
    const tN = rawPoses[rawPoses.length-1]?.t;
    const rows = [
      ["Poses in file", rawPoses.length],
      ["Watches in file", watches.length],
      ["Watches mapped on path", watchMarkers.length],
      ["Points kept from file", th.kept ?? "‚Äî"],
      ["Points removed from file", th.removed ?? "‚Äî"],
      ["Thinning ms", th.viewer_thin_ms ?? "‚Äî"],
      ["Time range", (typeof t0==="number" && typeof tN==="number") ? `${(t0 / 1000).toFixed(1)} ‚Äî ${(tN / 1000).toFixed(1)}s` : "‚Äî"],
    ];
    statsEl.innerHTML = "";
    for (const [k, v] of rows) {
      const a = document.createElement("div"); a.textContent = k;
      const b = document.createElement("div"); b.textContent = String(v);
      statsEl.appendChild(a); statsEl.appendChild(b);
    }
    statsHint.textContent = ``;
    bounds = { ...FIELD_BOUNDS_IN };
    computeTransform();

    setStatus(`Loaded ${rawPoses.length} poses, ${watches.length} watches.`);
    btnPlay.disabled = rawPoses.length < 2;
    btnFit.disabled = false;
    fieldSelect.disabled = false;

    updatePoseReadout();
    requestDrawAll();
  }

  async function handleFile(file) {
    try {
      const text = await file.text();
      const obj = JSON.parse(text);
      setData(obj);
    } catch (e) {
      console.error(e);
      setStatus(`Failed to load: ${e?.message || e}`);
    }
  }

  // -------- controls wiring --------
  btnFile.addEventListener('click', () => fileEl.click());
  fileEl.addEventListener('change', (e) => {
    const file = e.target.files?.[0];
    if (file) handleFile(file);
  });


  // Help modal
  function openHelp() {
    if (!helpModal) return;
    helpModal.hidden = false;
  }
  function closeHelp() {
    if (!helpModal) return;
    helpModal.hidden = true;
  }
  if (btnHelp) btnHelp.addEventListener('click', openHelp);
  if (btnHelpClose) btnHelpClose.addEventListener('click', closeHelp);
  if (helpModal) {
    helpModal.addEventListener('click', (e) => {
      if (e.target && (e.target.classList.contains('modalBackdrop'))) closeHelp();
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !helpModal.hidden) closeHelp();
    });
  }

  document.addEventListener('dragover', (e) => { e.preventDefault(); });
  document.addEventListener('drop', (e) => {
    e.preventDefault();
    const file = e.dataTransfer?.files?.[0];
    if (file) handleFile(file);
  });


  // Help modal
  function openHelp() {
    if (!helpModal) return;
    helpModal.hidden = false;
  }
  function closeHelp() {
    if (!helpModal) return;
    helpModal.hidden = true;
  }
  if (btnHelp) btnHelp.addEventListener('click', openHelp);
  if (btnHelpClose) btnHelpClose.addEventListener('click', closeHelp);
  if (helpModal) {
    helpModal.addEventListener('click', (e) => {
      if (e.target && (e.target.classList.contains('modalBackdrop'))) closeHelp();
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !helpModal.hidden) closeHelp();
    });
  }

  btnPlay.addEventListener('click', () => {
    if (!data) return;
    if (playing) { pause(); updatePoseReadout(); requestDrawAll(); }
    else play();
  });

  speedSelect.addEventListener('change', () => {
    playRate = Number(speedSelect.value) || 1;
  });

  btnFit.addEventListener('click', () => resetFieldPosition());

  fieldSelect.addEventListener('change', (e) => loadFieldImage(e.target.value));

  unitsSelect.addEventListener('change', (e) => {
    setUnitsFactorFromSelect(e.target.value);
    updateOffsetsFromInputs();
    requestDrawAll();
  });

  robotWEl.addEventListener('input', () => requestDrawAll());
  robotHEl.addEventListener('input', () => requestDrawAll());

  function syncRobotImgTxFromInputs() {
    robotImgTx.scale = clamp(Number(robotImgScaleEl?.value || 1), 0.05, 20);
    robotImgTx.offXIn = Number(robotImgOffXEl?.value || 0);
    robotImgTx.offYIn = Number(robotImgOffYEl?.value || 0);
    robotImgTx.rotDeg = Number(robotImgRotEl?.value || 0);
  }

  const onRobotImgInput = () => { syncRobotImgTxFromInputs(); requestDrawAll(); };

  if (robotImgScaleEl) robotImgScaleEl.addEventListener('input', onRobotImgInput);
  if (robotImgOffXEl) robotImgOffXEl.addEventListener('input', onRobotImgInput);
  if (robotImgOffYEl) robotImgOffYEl.addEventListener('input', onRobotImgInput);
  if (robotImgRotEl) robotImgRotEl.addEventListener('input', onRobotImgInput);


  minSpeedEl.addEventListener('input', () => { computeSpeedNorm(); recomputeWatchMarkers(); rebuildWatchMarkersByTime(); requestDrawAll(); updatePoseReadout(); });
  maxSpeedEl.addEventListener('input', () => { computeSpeedNorm(); recomputeWatchMarkers(); rebuildWatchMarkersByTime(); requestDrawAll(); updatePoseReadout(); });

  offXEl.addEventListener('input', updateOffsetsFromInputs);
  offYEl.addEventListener('input', updateOffsetsFromInputs);
  offThetaEl.addEventListener('input', updateOffsetsFromInputs);

  if (watchSort) watchSort.addEventListener('change', () => { renderWatchList(); requestDrawAll(); });

  const btnLeftClear = document.getElementById('btnClearField');

  function clearAllPosesAndWatches() {
    // Stop playback/hover/locks so UI doesn‚Äôt reference stale indices
    try { playing = false; } catch {}
    try { hoverTimelineTime = null; } catch {}
    try { trackHover = null; } catch {}
    try { trackLockActive = false; } catch {}
    try { trackLockPose = null; } catch {}
    try { trackLockIndex = null; } catch {}

    // Clear core data
    rawPoses = [];
    watches = [];

    // Clear any derived / UI lists if you have them
    try { watchMarkers = []; } catch {}
    try { watchByLabel = {}; } catch {}
    try { lastPoseIndex = 0; } catch {}
    try { livePendingLines = []; livePendingConsumed = 0; } catch {}

    // Keep `data` consistent if you use it elsewhere
    if (typeof data === "object" && data) {
      data.poses = [];
      data.watches = [];
    }

    // Reset selection + redraw
    selectedIndex = 0;

    // If you have helper functions, call them; guard so no crashes
    try { renderPoseList?.(); } catch {}
    try { renderWatchList?.(); } catch {}
    try { updatePoseReadout?.(); } catch {}
    try { updateFloatingInfo?.(null, 0); } catch {}
    try { requestDrawAll?.(); } catch {}

    setStatus("Cleared field (poses + watches).");
  }

  btnLeftClear?.addEventListener('click', () => {
    clearAllPosesAndWatches();
  });

  document.addEventListener('keydown', (e) => {
    if (!data) return;
    // Don't steal keys while typing in inputs/textareas (except the read-only live window).
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    const isTyping = (tag === "input" || tag === "textarea" || (e.target && e.target.isContentEditable));
    if (isTyping && e.target !== liveWinEl) return;

    // Space toggles "auto-follow head" while connected in livestream mode.
    if (e.code === "Space" && leftConnected) {
      e.preventDefault();
      if (liveAutoFollowHead) {
        // about to turn it OFF => freeze at current index
        lastPoseIndex = selectedIndex;
        liveAutoFollowHead = false;
      } else {
        liveAutoFollowHead = true;
      }
      if (window.__live) window.__live.autoFollowHead = !!liveAutoFollowHead;
      setStatus(`Live View: Auto-follow head: ${liveAutoFollowHead ? "ON" : "OFF"} (Space)`);
      return;
    } else if (e.code === "Space") {
      e.preventDefault();
      playing ? (pause(), updatePoseReadout(), requestDrawAll()) : play();
    }

    if (e.code === "ArrowLeft") {
      console.clear();
            console.log(`Last pose: ${lastPoseIndex}`);
      console.log(`Selected index: ${selectedIndex}`);
      console.log(`liveAutoFollowHead: ${liveAutoFollowHead}`);
      return;
      e.preventDefault();
      pause();
      clearTrackHover(true);
      clearTrackLock();
      selectedWatch = null;
      selectedIndex = Math.max(0, selectedIndex-1);
      highlightPoseInList();
      updatePoseReadout();
      requestDrawAll();
    }
    if (e.code === "ArrowRight") {
      e.preventDefault();
      pause();
      clearTrackHover(true);
      clearTrackLock();
      selectedWatch = null;
      selectedIndex = Math.min(rawPoses.length-1, selectedIndex+1);
      highlightPoseInList();
      updatePoseReadout();
      requestDrawAll();
    }
  });

  // -------- init --------
  loadFieldOptions();
  window.addEventListener('resize', () => {
    updateFieldLayout(true); // keep bounds, recompute square sizing
    resizeTimeline();
  });

  updateFieldLayout(false);
  resizeTimeline();
  if (robotImgControlsEl) robotImgControlsEl.hidden = true;
  syncRobotImgTxFromInputs();
  loadRobotImage();
  drawFirstField();
})();

</script>
<div id="watchPopup" hidden></div>
</body>
</html>