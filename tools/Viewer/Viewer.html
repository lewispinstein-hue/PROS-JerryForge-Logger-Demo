<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JerryForge Viewer (Offline)</title>
  <style>
    :root { --bg:#0b0f14; --panel:#101720; --text:#e7eef7; --muted:#93a4b8; --line:#233244; }
    * { box-sizing:border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:var(--bg); color:var(--text); }
    header { padding:10px 14px; border-bottom:1px solid var(--line); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header .grow { flex:1 1 auto; min-width: 180px; }
    button, select, input[type="file"], input[type="number"] {
      background:var(--panel); color:var(--text); border:1px solid var(--line);
      padding:8px 10px; border-radius:10px; max-width:100%;
    }
    button { cursor:pointer; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .muted { color:var(--muted); font-size:12px; }

    /* Layout: content row + bottom timeline */
    .app {
      height: calc(100vh - 56px);
      display:flex;
      flex-direction:column;
      min-height: 0;
    }
    .row {
      flex: 1 1 auto;
      display:flex;
      min-height:0;
      overflow:hidden;
    }
    #canvasWrap { flex:1 1 auto; position:relative; overflow:hidden; min-width: 0; }
    canvas#c { width:100%; height:100%; display:block; }

    /* Sidebar: flexible width, wraps content, no horizontal scroll */
    #right {
      flex: 0 0 clamp(260px, 26vw, 420px);
      border-left:1px solid var(--line);
      background:rgba(16,23,32,.7);
      backdrop-filter: blur(6px);
      overflow:auto;
      min-width: 240px;
    }
    #right * { min-width: 0; }
    #right .section { padding:12px 14px; border-bottom:1px solid var(--line); }
    .drop { border:1px dashed var(--line); border-radius:12px; padding:10px; }

    details { border: 1px solid var(--line); border-radius: 12px; overflow: hidden; background: rgba(16,23,32,.45); }
    details > summary {
      cursor: pointer;
      padding: 10px 12px;
      user-select: none;
      list-style: none;
      display:flex; align-items:center; justify-content:space-between;
      font-weight: 750;
      gap: 8px;
      flex-wrap: wrap;
    }
    details > summary::-webkit-details-marker { display:none; }
    .detailsBody { padding: 10px 12px; border-top:1px solid var(--line); }

    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--line); font-size:12px; color:var(--muted); white-space:nowrap; }
    .pill.level { border-color: transparent; color: #081018; font-weight: 800; }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .grid3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
    @media (max-width: 980px) {
      #right { flex-basis: 320px; }
      .grid3 { grid-template-columns: 1fr 1fr; }
    }
    @media (max-width: 740px) {
      .row { flex-direction:column; }
      #right { flex: 0 0 auto; max-height: 44vh; border-left:none; border-top:1px solid var(--line); }
    }

    label { font-size:12px; color:var(--muted); display:block; margin-bottom:4px; }

    #watchList { max-height: 40vh; overflow:auto; border:1px solid var(--line); border-radius:10px; }
    .watchItem { padding:10px 10px; border-bottom:1px solid var(--line); cursor:pointer; overflow:hidden; }
    .watchItem:hover { background: rgba(255,255,255,.04); }
    .watchItem:last-child { border-bottom:none; }
    .watchItem.selected { outline: 2px solid rgba(255,255,255,0.35); outline-offset:-2px; background: rgba(255,255,255,.03); }
    .bigValue { font-size: 15px; font-weight: 800; margin-top: 6px; word-break: break-word; }

    .kvs { display:grid; grid-template-columns: 1fr auto; gap:6px 10px; font-size:13px; }
    .kvs div:nth-child(2n) { color:var(--muted); text-align:right; }

    /* Bottom timeline */
    #timelineBar {
      flex: 0 0 96px;
      border-top:1px solid var(--line);
      background: rgba(8,12,18,0.95);
      display:flex;
      flex-direction:column;
      padding: 10px 12px;
      gap: 8px;
    }
    #timelineTop {
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
    }
    #timelineCanvas {
      width:100%;
      height: 54px;
      border:1px solid var(--line);
      border-radius: 12px;
      background: rgba(16,23,32,0.55);
      display:block;
    }
    #timelineHint { color: var(--muted); font-size: 12px; }
  
  :root{
    --sidebarW: 360px;
    --timelineH: 260px;
    --toolbarH: 54px;
  }
  header.toolbar{
    display:flex;
    align-items:center;
    gap:10px;
    padding:10px 12px;
    border-bottom:1px solid rgba(255,255,255,0.08);
    background: linear-gradient(180deg, rgba(8,14,22,0.92), rgba(8,14,22,0.80));
    position: sticky;
    top: 0;
    z-index: 50;
    height: var(--toolbarH);
    box-sizing: border-box;
  }
  .iconBtn{
    height: 34px;
    min-width: 38px;
    padding: 0 10px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.04);
    color: #e9eef7;
    font-size: 16px;
    cursor: pointer;
  }
  .iconBtn:disabled{ opacity:0.4; cursor:not-allowed; }
  .chip{
    display:flex;
    align-items:center;
    gap:8px;
    padding:6px 10px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.03);
    height: 34px;
    box-sizing: border-box;
  }
  .chip select{
    background: rgba(0,0,0,0.25);
    border: 1px solid rgba(255,255,255,0.12);
    color: inherit;
    border-radius: 10px;
    padding: 4px 8px;
    height: 24px;
  }
  .rowline{ display:flex; align-items:center; gap:10px; }
  .divider{ height:1px; background: rgba(255,255,255,0.10); }

  /* App layout with resizable sidebar + resizable timeline */
  .app{
    height: calc(100vh - var(--toolbarH));
    display: grid;
    grid-template-rows: 1fr 8px var(--timelineH);
    overflow: hidden;
  }
  .row{
    display: grid;
    grid-template-columns: 1fr 8px var(--sidebarW);
    overflow: hidden;
    min-height: 0;
  }
  #canvasWrap{ min-width:0; min-height:0; }
  #right{ min-width: 240px; overflow:auto; }
  .splitterV{
    cursor: col-resize;
    background: rgba(255,255,255,0.06);
    border-left: 1px solid rgba(255,255,255,0.08);
    border-right: 1px solid rgba(255,255,255,0.08);
  }
  .splitterV:hover{ background: rgba(255,255,255,0.10); }
  .splitterH{
    cursor: row-resize;
    background: rgba(255,255,255,0.06);
    border-top: 1px solid rgba(255,255,255,0.08);
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }
  .splitterH:hover{ background: rgba(255,255,255,0.10); }

  /* Timeline bar should never clip its contents */
  #timelineBar{
    height: var(--timelineH);
    min-height: 140px;
    overflow: hidden;
    display:flex;
    flex-direction:column;
  }
  #timelineCanvas{ flex: 1 1 auto; min-height: 0; }
  #timelineHint{ padding-bottom: 8px; }
  /* --- Collapsible panels: when fully dragged closed, only handle remains --- */
  #right.isCollapsed { display:none !important; }
  #timelineBar.isCollapsed { display:none !important; }

  /* Keep splitters visible even when panels are collapsed */
  .splitterV, .splitterH {
    position: relative;
    user-select: none;
    touch-action: none;
  }
  .splitterV::after {
    content: "â‹®";
    position:absolute;
    left:50%; top:50%;
    transform: translate(-50%,-50%);
    color: rgba(255,255,255,0.55);
    font-size: 14px;
    pointer-events:none;
  }
  .splitterH::after {
    content: "â‹¯";
    position:absolute;
    left:50%; top:50%;
    transform: translate(-50%,-50%);
    color: rgba(255,255,255,0.55);
    font-size: 16px;
    pointer-events:none;
  }

  /* Pose list items */
  .poseItem { padding:8px 10px; border-bottom:1px solid var(--line); cursor:pointer; }
  .poseItem:hover { background: rgba(255,255,255,.04); }
  .poseItem:last-child { border-bottom:none; }
  .poseItem.selected { outline: 2px solid rgba(255,255,255,0.35); outline-offset:-2px; background: rgba(255,255,255,.03); }



    /* === Help modal === */
    .modal { position:fixed; inset:0; z-index:80; }
    .modalBackdrop { position:absolute; inset:0; background:rgba(0,0,0,0.55); }
    .modalCard { position:relative; width:min(720px, calc(100vw - 28px)); max-height:calc(100vh - 28px);
                 margin:14px auto; background:var(--panel); border:1px solid var(--line);
                 border-radius:14px; overflow:hidden; box-shadow:0 12px 40px rgba(0,0,0,0.45); }
    .modalHeader { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; border-bottom:1px solid var(--line); }
    .modalBody { padding:12px; overflow:auto; color:var(--text); }
    .modalBody a { color:#9fd1ff; text-decoration:none; }
    .modalBody a:hover { text-decoration:underline; }

    /* === Watch click popup (tiny) === */
    #watchPopup { position:fixed; z-index:90; background:rgba(16,23,32,0.98);
                  border:1px solid var(--line); border-radius:10px; padding:8px 10px;
                  font-size:12px; line-height:1.25; max-width:340px;
                  box-shadow:0 10px 24px rgba(0,0,0,0.40); }
    #watchPopup .row { display:flex; gap:8px; }
    #watchPopup .k { color:var(--muted); min-width:54px; }
    #watchPopup .v { color:var(--text); word-break:break-word; }

    /* tighten pose list */
    .poseItem .sub { margin-top:3px; font-size:12px; color:var(--muted); }

  </style>
</head>
<body>
<header class="toolbar">
  <input id="file" type="file" accept=".json" style="display:none" />
  <button id="btnFile" class="iconBtn" title="Open JSON">ðŸ“„</button>
  <button id="btnPlay" class="iconBtn" title="Play/Pause" disabled>â–¶</button>
  <div class="chip">
    <span class="muted">Speed</span>
    <select id="speedSelect" title="Playback speed">
      <option value="0.25">0.25Ã—</option>
      <option value="0.5">0.5Ã—</option>
      <option value="1" selected>1Ã—</option>
      <option value="2">2Ã—</option>
      <option value="4">4Ã—</option>
    </select>
  </div>
  <button id="btnFit" class="iconBtn" title="Fit to path" disabled>â¤¢</button>

  <div class="chip">
    <span class="muted">Field</span>
    <select id="fieldSelect" title="Field image">
      <option value="">No field image</option>
    </select>
  </div>

  <button id="btnHelp" class="iconBtn" title="Help">?</button>
  <span class="grow muted" id="status">Drop a viewer JSON file.</span>
</header>


<div id="helpModal" class="modal" hidden>
  <div class="modalBackdrop"></div>
  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modalHeader">
      <div id="helpTitle" style="font-weight:900;font-size:16px">JerryForge Viewer â€” Help</div>
      <button id="btnHelpClose" class="iconBtn" title="Close">âœ•</button>
    </div>
    <div class="modalBody">
      <p style="margin-top:0">
        This is an <b>offline viewer</b> for robot logs produced by the JerryForge logger demo project.
      </p>
      <p>
        Use it with JSON files generated by:
        <a href="https://github.com/lewispinstein-hue/PROS-JerryForge-Logger-Demo" target="_blank" rel="noreferrer">
          PROS-JerryForge-Logger-Demo
        </a>
      </p>
      <div style="margin-top:10px">
        <div style="font-weight:850;margin-bottom:6px">Main elements</div>
        <ul style="margin:0;padding-left:18px">
          <li><b>Field view</b>: robot path + pose, watches, hover/click to preview/lock.</li>
          <li><b>Timeline</b>: scrub through time; hover previews, click jumps.</li>
          <li><b>Sidebar</b>: config, watches list, poses list.</li>
        </ul>
      </div>
      <div style="margin-top:10px" class="muted">
        Tip: Drag the thin handles to resize/collapse the sidebar (left) and timeline (bottom).
      </div>
    </div>
  </div>
</div>


<div class="app">
  <div class="row">
    <div id="canvasWrap">
      <canvas id="c" title="Field view: hover path to preview robot pose; click to lock; click watches for details"></canvas>
    </div>

    <div id="vSplit" class="splitterV" title="Drag to resize"></div>

    <div id="right">
      <div class="section">
        <div class="drop muted">
          Tip: drag & drop a <code>*-viewer.json</code> file anywhere on the page.
        </div>
      </div>

      <div class="section">
        <details open id="secGeneral">
          <summary>
            <span>Config</span>
            <span class="pill" id="fmt">no file</span>
          </summary>
          <div class="detailsBody">
            <div style="font-weight:800" id="runName">â€”</div>
            <div class="muted" id="runMeta">â€”</div>

            <div style="margin-top:12px" class="grid2">
              <div>
                <label>Units (interpret input poses as)</label>
                <select id="unitsSelect">
                  <option value="in">inches</option>
                  <option value="cm">centimeters</option>
                  <option value="ft">foot</option>
                  <option value="tiles">tiles (24 in)</option>
                </select>
                <div class="muted" style="margin-top:6px">
                  Rendering uses inches internally.
                </div>
              </div>
              <div>
                <label>Robot size (inches on field)</label>
                <div class="grid2">
                  <input id="robotW" type="number" step="0.5" value="12" />
                  <input id="robotH" type="number" step="0.5" value="12" />
                </div>
                <div class="muted" style="margin-top:6px">width / height</div>
              </div>
            </div>

            <div style="margin-top:12px" class="grid3">
              <div>
                <label>X Offset</label>
                <input id="offX" type="number" step="0.1" value="0" />
              </div>
              <div>
                <label>Y Offset</label>
                <input id="offY" type="number" step="0.1" value="0" />
              </div>
              <div>
                <label>Theta Offset (deg)</label>
                <input id="offTheta" type="number" step="1" value="0" />
              </div>
            </div>
            <div class="muted" style="margin-top:8px">
              Offsets move the whole path relative to the field. (No auto-fit on offset changes.)
            </div>

            <div class="divider" style="margin:14px 0;"></div>
            <div style="font-weight:800; margin-bottom:6px">Stats</div>
            
            <div class="grid2" style="margin-bottom:10px">
              <div>
                <label>Min speed (normalize)</label>
                <input id="minSpeed" type="number" title="Minimum speed used for color normalization (red=slow)" step="1" value="0" />
              </div>
              <div>
                <label>Max speed (normalize)</label>
                <input id="maxSpeed" type="number" title="Maximum speed used for color normalization (green=fast)" step="1" value="127" />
              </div>
            </div>
            <div class="kvs" id="stats"></div>
          
</div>
        </details>
      </div>

      <div class="section">
        <details open id="secWatches">
          <summary>
            <span>Watches</span>
            <span class="pill" id="watchCount">â€”</span>
          </summary>
          <div class="detailsBody">
            <div class="rowline" style="margin-bottom:8px">
              <span class="muted">Sort</span>
              <select id="watchSort" style="margin-left:auto">
                <option value="level">level</option>
                <option value="time" selected>time</option>
                <option value="-time">-time</option>
                <option value="value">value</option>
              </select>
            </div>

            <div id="watchList"></div>
            <div class="muted" style="margin-top:10px">
              Click a watch to highlight it on the field and on the timeline.
            </div>
          </div>
        </details>
      </div>

      
      <div class="section">
        <details open id="secPoses">
          <summary>
            <span>Poses</span>
            <span class="pill" id="poseCount">â€”</span>
          </summary>
          <div class="detailsBody">
            <div class="muted" style="margin-bottom:8px">Click a pose to jump.</div>
            <div id="poseList" title="Click a pose to jump the robot to that recorded moment" style="max-height: 40vh; overflow:auto; border:1px solid var(--line); border-radius:10px;"></div>
          </div>
        </details>
      </div>

    </div>
  </div>

  <div id="hSplit" class="splitterH" title="Drag to resize timeline"></div>

  <!-- Bottom timeline bar -->
  <div id="timelineBar">
    <div id="timelineTop">
      <span class="pill" id="timePill">Time: â€”</span>
      <span class="pill" id="pointPill">Point: â€”/â€”</span>
      <span class="pill poseReadout" id="posePill">
        <span class="kv"><span class="k">X</span><span class="v" id="poseX">â€”</span></span>
        <span class="kv"><span class="k">Y</span><span class="v" id="poseY">â€”</span></span>
        <span class="kv"><span class="k">Î¸</span><span class="v" id="poseTh">â€”</span></span>
        <span class="kv"><span class="k">Speed</span><span class="v" id="poseSp">â€”</span></span>
        <span class="kv"><span class="k">n</span><span class="v" id="poseSn">â€”</span></span>
      </span>
    </div>
    <canvas id="timelineCanvas"></canvas>
    <div id="timelineHint" class="muted">
      Hover: preview robot at time â€¢ Click: set time â€¢ Watch dots are clickable
    </div>
  </div>
</div>

<script>
(() => {
  const root = document.documentElement;

  const canvas = document.getElementById('c');
  // Track last mouse position (for small popups)
  let lastMouseClient = { x: 20, y: 20 };
  window.addEventListener('mousemove', (e) => { lastMouseClient = { x: e.clientX, y: e.clientY }; }, { passive: true });

  const ctx = canvas.getContext('2d');

  const timelineCanvas = document.getElementById('timelineCanvas');
  const tctx = timelineCanvas.getContext('2d');

  const statusEl = document.getElementById('status');
  const fileEl = document.getElementById('file');
  const btnPlay = document.getElementById('btnPlay');
  const btnFit = document.getElementById('btnFit');
  const btnFile = document.getElementById('btnFile');
  const btnHelp = document.getElementById('btnHelp');
  const helpModal = document.getElementById('helpModal');
  const btnHelpClose = document.getElementById('btnHelpClose');
  const speedSelect = document.getElementById('speedSelect');
  const watchSort = document.getElementById('watchSort');
  const vSplit = document.getElementById('vSplit');
  const hSplit = document.getElementById('hSplit');
  const timePill = document.getElementById('timePill');
  const pointPill = document.getElementById('pointPill');
  const posePill = document.getElementById('posePill');

  const rightEl = document.getElementById('right');
  const timelineBar = document.getElementById('timelineBar');
  const timelineTop = document.getElementById('timelineTop');
  const timelineHint = document.getElementById('timelineHint');

  const runName = document.getElementById('runName');
  const runMeta = document.getElementById('runMeta');
  const fmt = document.getElementById('fmt');
  const statsEl = document.getElementById('stats');
  const watchList = document.getElementById('watchList');
  const watchCount = document.getElementById('watchCount');
  const secWatches = document.getElementById('secWatches');
  const fieldSelect = document.getElementById('fieldSelect');

  const poseList = document.getElementById('poseList');
  const poseCount = document.getElementById('poseCount');

  const offXEl = document.getElementById('offX');
  const offYEl = document.getElementById('offY');
  const offThetaEl = document.getElementById('offTheta');
  const unitsSelect = document.getElementById('unitsSelect');
  const robotWEl = document.getElementById('robotW');
  const robotHEl = document.getElementById('robotH');
  const minSpeedEl = document.getElementById('minSpeed');
  const maxSpeedEl = document.getElementById('maxSpeed');

  // --- FIELD IMAGES ---
  const FIELD_IMAGES = [
    { key: "./assets/match_field_2025-2026_pushback.png", label: "Field: Match Field" },
    { key: "./assets/skills_field_2025-2026_pushback.png", label: "Field: Skills Field" },
  ];

  // Default field image
  const DEFAULT_FIELD_KEY = FIELD_IMAGES[0].key;

  // Field bounds in INCHES (default view when no Fit)
  const FIELD_BOUNDS_IN = { minX: -72, maxX: 72, minY: -72, maxY: 72, pad: 30 };

  const WATCH_TOL_MS = 40; // Controls the Â± time that determines which pose a watch attaches to
  const HOVER_PIXEL_TOL = 14;
  const COLLAPSE_PX = 60; // When the sidebar / timeline collapses away

  let data = null;

  // Raw poses are stored in FILE units; we convert to inches for rendering.
  // Fields: t, x, y, theta, l_vel, r_vel, speed_raw, speed_norm
  let rawPoses = [];

  // Watches: normalized
  let watches = [];
  let watchMarkers = []; // {watch, t, pose(in), ok, idx, dt}

  let selectedWatch = null;       // { marker }
  let selectedIndex = 0;          // nearest pose index for "locked" selection
  let hoverTimelineTime = null;   // preview time on timeline (ms)
  let timelineHoverSaved = null;  // { index, lockActive, lockPose, lockIndex }

  let hoverWatch = null;

  // Track preview + lock
  let trackHover = null;          // { pose, idxNearest }
  let trackHoverSavedIndex = null;
  let trackLockActive = false;
  let trackLockPose = null;       // pose in inches
  let trackLockIndex = null;

  // playback
  let playing = false;
  let raf = null;
  let playTimeMs = null;
  let lastWall = null;
  let playRate = 1;

  // world->screen
  let bounds = { ...FIELD_BOUNDS_IN };
  let scale = 1;
  let offsetXpx = 0;
  let offsetYpx = 0;

  // field image
  let fieldImg = null;

  // offsets: entered in selected units, stored as inches for rendering
  const offsetsIn = { x: 0, y: 0, theta: 0 };
  let unitsToInFactor = 1;

  // -------- utilities --------
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function normalizeDeg(d) { let x = d % 360; if (x < 0) x += 360; return x; }
  function angLerpDeg(a, b, t) {
    a = normalizeDeg(a); b = normalizeDeg(b);
    let diff = (b - a + 540) % 360 - 180;
    return normalizeDeg(a + diff * t);
  }
  function fmtNum(v, d=2) { if (typeof v !== "number" || !isFinite(v)) return "â€”"; return v.toFixed(d); }
  function setStatus(msg) { statusEl.textContent = msg; }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (c) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c]));
  }

  function toNumMaybe(v) {
    if (typeof v === "number" && isFinite(v)) return v;
    if (typeof v === "string") {
      const n = Number(v.trim());
      if (isFinite(n)) return n;
    }
    return null;
  }

  function levelStyle(levelRaw) {
    const L = String(levelRaw || "INFO").toUpperCase();
    if (L.includes("ERROR") || L.includes("FATAL")) return { name:"ERROR", fill:"rgb(255,77,77)", text:"#081018" };
    if (L.includes("WARN")) return { name:"WARN", fill:"rgb(255,212,77)", text:"#081018" };
    if (L.includes("DEBUG")) return { name:"DEBUG", fill:"rgb(154,167,187)", text:"#081018" };
    return { name:"INFO", fill:"rgb(77,255,136)", text:"#081018" };
  }

  function robotDimsInches() {
    const w = Number(robotWEl.value || 12);
    const h = Number(robotHEl.value || 12);
    return { w: Math.max(1, w), h: Math.max(1, h) };
  }

  // -------- units/offsets --------
  function setUnitsFactorFromSelect(value) {
    if (value === "cm") unitsToInFactor = 1 / 2.54;
    else if (value === "ft") unitsToInFactor = 12;
    else if (value === "tiles") unitsToInFactor = 24;
    else unitsToInFactor = 1;
  }

  function inferUnitsFromMeta(metaUnits) {
    const u = String(metaUnits || "").toLowerCase().trim();
    if (!u) return "in";
    if (u.includes("tile")) return "tiles";
    if (u.includes("cm") || u.includes("cent")) return "cm";
    if (u === "ft" || u.includes("foot") || u.includes("feet")) return "ft";
    if (u.includes("in")) return "in";
    return "in";
  }

  function updateOffsetsFromInputs() {
    const ux = Number(offXEl.value || 0);
    const uy = Number(offYEl.value || 0);
    const ut = Number(offThetaEl.value || 0);

    offsetsIn.x = ux * unitsToInFactor;
    offsetsIn.y = uy * unitsToInFactor;
    offsetsIn.theta = ut;

    recomputeWatchMarkers();
    draw();
    updatePoseReadout();
    drawTimeline();
  }

  // -------- speed normalization (single source of truth) --------
  function getMinMaxSpeed() {
    let minV = Number(minSpeedEl.value);
    let maxV = Number(maxSpeedEl.value);
    minV = (isFinite(minV) ? minV : 0);
    maxV = (isFinite(maxV) ? maxV : 127);
    if (minV > maxV) { const tmp = minV; minV = maxV; maxV = tmp; }
    return { minV, maxV };
  }

  function computeSpeedNorm() {
    const { minV, maxV } = getMinMaxSpeed();
    const denom = (maxV - minV) || 1;
    for (const p of rawPoses) {
      const s = Math.abs(p.speed_raw ?? 0);
      p.speed_norm = clamp((s - minV) / denom, 0, 1);
    }
  }

  function heatColorFromNorm(n) {
    // n=0 -> red-ish, n=1 -> green-ish
    const t = clamp(n, 0, 1);
    const u = 1 - t; // u=1 red, u=0 green

    let r,g,b;
    if (u <= 0.33) {
      const a = u / 0.33;
      r = 40 + a*(255-40); g = 220; b = 80;
    } else if (u <= 0.66) {
      const a = (u-0.33)/0.33;
      r = 255; g = 220 - a*(140); b = 80 - a*(40);
    } else {
      const a = (u-0.66)/0.34;
      r = 255; g = 80 - a*(70); b = 40 - a*(30);
    }
    return `rgba(${Math.round(r)},${Math.round(g)},${Math.round(b)},0.88)`;
  }

  // -------- pose conversion --------
  function poseToInches(p) {
    return {
      t: (typeof p.t === "number") ? p.t : null,
      x: (p.x ?? 0) * unitsToInFactor + offsetsIn.x,
      y: (p.y ?? 0) * unitsToInFactor + offsetsIn.y,
      theta: normalizeDeg((p.theta ?? 0) + offsetsIn.theta),
      l_vel: (typeof p.l_vel === "number") ? p.l_vel : null,
      r_vel: (typeof p.r_vel === "number") ? p.r_vel : null,
      speed_raw: (typeof p.speed_raw === "number") ? p.speed_raw : null,
      speed_norm: (typeof p.speed_norm === "number") ? p.speed_norm : 0,
    };
  }

  function getPosesInches() { return rawPoses.map(poseToInches); }

  // -------- canvas sizing/transform --------
  function computeTransform() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const pad = bounds.pad;
    const worldW = (bounds.maxX - bounds.minX) || 1;
    const worldH = (bounds.maxY - bounds.minY) || 1;
    scale = Math.min((w - pad*2) / worldW, (h - pad*2) / worldH);
    offsetXpx = pad - bounds.minX * scale;
    offsetYpx = pad + bounds.maxY * scale;
  }

  function worldToScreen(xIn, yIn) {
    return { x: offsetXpx + xIn * scale, y: offsetYpx - yIn * scale };
  }

  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    computeTransform();
    draw();
  }

  function layoutTimelineCanvas() {
    if (!timelineCanvas || !timelineBar) return;
    if (timelineBar.classList.contains('isCollapsed')) return;

    // Ensure we never clip the bottom: compute available height.
    const barH = timelineBar.getBoundingClientRect().height;
    const topH = timelineTop ? timelineTop.getBoundingClientRect().height : 0;
    const hintH = timelineHint ? timelineHint.getBoundingClientRect().height : 0;
    const padding = 10 + 10; // rough internal padding
    const avail = Math.max(44, barH - topH - hintH - padding);
    timelineCanvas.style.height = `${avail}px`;
  }

  function resizeTimeline() {
    layoutTimelineCanvas();
    const dpr = window.devicePixelRatio || 1;
    const rect = timelineCanvas.getBoundingClientRect();
    timelineCanvas.width = Math.max(1, Math.floor(rect.width * dpr));
    timelineCanvas.height = Math.max(1, Math.floor(rect.height * dpr));
    tctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    drawTimeline();
  }

  // -------- field images --------
  function loadFieldOptions() {
    fieldSelect.innerHTML = `<option value="">No field image</option>`;
    for (const f of FIELD_IMAGES) {
      const opt = document.createElement('option');
      opt.value = f.key;
      opt.textContent = f.label;
      fieldSelect.appendChild(opt);
    }
  }

  async function loadFieldImage(filename) {
    if (!filename) { fieldImg = null; draw(); return; }
    const img = new Image();
    img.onload = () => { fieldImg = img; draw(); };
    img.onerror = () => { fieldImg = null; setStatus(`Could not load field image: ${filename}`); draw(); };
    img.src = filename;
  }

  function drawFirstField() {
    loadFieldOptions();

    // Set the default selection and trigger the load
    const defaultField = FIELD_IMAGES.find(f => f.key === DEFAULT_FIELD_KEY);
    
    if (defaultField) {
      fieldSelect.value = defaultField.key; 
      loadFieldImage(defaultField.key); 
    }
  }

  // -------- time helpers --------
  function timeRange() {
    const t0 = rawPoses[0]?.t;
    const tN = rawPoses[rawPoses.length-1]?.t;
    if (typeof t0 !== "number" || typeof tN !== "number" || tN <= t0) return null;
    return { t0, tN };
  }

  function findFloorIndexByTime(tMs) {
    const poses = rawPoses;
    if (!poses.length) return -1;
    let lo = 0, hi = poses.length - 1;
    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      const tm = poses[mid].t ?? -Infinity;
      if (tm <= tMs) lo = mid + 1;
      else hi = mid - 1;
    }
    return clamp(hi, 0, poses.length - 1);
  }

  function interpolatePoseAtTime(tMs) {
    if (!rawPoses.length) return null;
    const i = findFloorIndexByTime(tMs);
    const p0 = rawPoses[i];
    if (i >= rawPoses.length - 1) return poseToInches({ ...p0, t: p0.t });

    const p1 = rawPoses[i+1];
    const t0 = p0.t ?? tMs;
    const t1 = p1.t ?? t0;
    const denom = (t1 - t0) || 1;
    const a = clamp((tMs - t0) / denom, 0, 1);

    const x = (p0.x ?? 0) + ((p1.x ?? 0) - (p0.x ?? 0)) * a;
    const y = (p0.y ?? 0) + ((p1.y ?? 0) - (p0.y ?? 0)) * a;
    const theta = angLerpDeg(p0.theta ?? 0, p1.theta ?? 0, a);

    const l_vel = (p0.l_vel ?? 0) + ((p1.l_vel ?? 0) - (p0.l_vel ?? 0)) * a;
    const r_vel = (p0.r_vel ?? 0) + ((p1.r_vel ?? 0) - (p0.r_vel ?? 0)) * a;

    const s0 = (p0.speed_raw ?? 0), s1 = (p1.speed_raw ?? 0);
    const speed_raw = s0 + (s1 - s0) * a;
    const speed_norm = (p0.speed_norm ?? 0) + ((p1.speed_norm ?? 0) - (p0.speed_norm ?? 0)) * a;

    // feed in file units and norm; poseToInches will reapply offsets for x/y/theta
    return poseToInches({ t: tMs, x, y, theta, l_vel, r_vel, speed_raw, speed_norm });
  }

  function nearestIndexWithinTol(tMs, tolMs) {
    if (!rawPoses.length) return null;
    const i0 = findFloorIndexByTime(tMs);
    const cands = [i0, Math.min(i0+1, rawPoses.length-1)];
    let best = null;
    for (const i of cands) {
      const tt = rawPoses[i].t;
      if (typeof tt !== "number") continue;
      const dt = Math.abs(tt - tMs);
      if (best === null || dt < best.dt) best = { idx: i, dt };
    }
    if (best && best.dt <= tolMs) return best;
    return null;
  }

  // -------- watches --------
  function normalizeWatches(arr) {
    const out = [];
    if (!Array.isArray(arr)) return out;

    for (const w of arr) {
      if (!w || typeof w !== "object") continue;
      const tRaw = (w.t ?? w.timestamp ?? w.time ?? w.ms);
      const t = toNumMaybe(tRaw);
      if (t == null) continue;

      out.push({
        t,
        level: w.level ?? w.lvl ?? w.severity ?? "INFO",
        label: w.label ?? w.name ?? "",
        value: (w.value ?? w.val ?? w.message ?? ""),
      });
    }
    out.sort((a,b) => a.t - b.t);
    return out;
  }

  function recomputeWatchMarkers() {
    watchMarkers = [];
    for (const w of watches) {
      const t = w.t;
      const near = nearestIndexWithinTol(t, WATCH_TOL_MS);
      if (near) {
        const p = rawPoses[near.idx];
        watchMarkers.push({ watch: w, t, ok: true, dt: near.dt, pose: poseToInches(p), idx: near.idx });
      } else {
        const ip = interpolatePoseAtTime(t);
        if (ip) watchMarkers.push({ watch: w, t, ok: false, dt: null, pose: ip, idx: null });
      }
    }
  }

  // watchMarkersByTime is used for fast "last watch hit" lookup during playback
  let watchMarkersByTime = [];

  function rebuildWatchMarkersByTime() {
    watchMarkersByTime = watchMarkers.slice().sort((a,b) => (a.t ?? 0) - (b.t ?? 0));
  }

  function lastWatchAtTime(tMs) {
    if (!watchMarkersByTime.length) return null;
    let lo = 0, hi = watchMarkersByTime.length - 1;
    if ((watchMarkersByTime[0].t ?? 0) > tMs) return null;
    while (lo < hi) {
      const mid = Math.ceil((lo + hi) / 2);
      const tm = watchMarkersByTime[mid].t ?? 0;
      if (tm <= tMs) lo = mid; else hi = mid - 1;
    }
    return watchMarkersByTime[lo];
  }


  function highlightWatchInList(tMs, doScroll) {
    const items = watchList.querySelectorAll(".watchItem");
    items.forEach(el => el.classList.remove("selected"));
    const el = watchList.querySelector(`.watchItem[data-t="${CSS.escape(String(tMs))}"]`);
    if (el) {
      el.classList.add("selected");
      if (doScroll) requestAnimationFrame(() => el.scrollIntoView({ block: "nearest" }));
    }
  }

  // --- Watch popup (tiny, click to show, click elsewhere to dismiss) ---
  const watchPopup = document.getElementById('watchPopup');
  let watchPopupOpen = false;

  function hideWatchPopup() {
    if (!watchPopup) return;
    watchPopup.hidden = true;
    watchPopupOpen = false;
  }

  function fmtPose(p) {
    if (!p) return "â€”";
    const x = (p.x ?? 0).toFixed(1);
    const y = (p.y ?? 0).toFixed(1);
    const th = (p.theta ?? 0).toFixed(1);
    return `X: ${x}in, Y: ${y}in, Î¸: ${th}Â°`;
  }

  function showWatchPopup(marker, clickPos) {
    if (!watchPopup || !marker) return;

    const w = marker.watch || {};
    const pose = marker.pose || interpolatePoseAtTime(marker.t);
    const poseStr = fmtPose(pose);

    const tStr = (marker.t != null) ? `${marker.t}ms` : "â€”";
    const watchStr = w.watch || w.name || w.key || "watch";
    const labelStr = w.label || "â€”";
    const valStr = (w.value == null) ? "â€”" : String(w.value);

    watchPopup.innerHTML = `
      <div class="row"><div class="k">time</div><div class="v">${escapeHtml(tStr)}</div></div>
      <div class="row"><div class="k">pose</div><div class="v">${escapeHtml(poseStr)}</div></div>
      <div class="row"><div class="k">watch</div><div class="v">${escapeHtml(String(watchStr))}</div></div>
      <div class="row"><div class="k">label</div><div class="v">${escapeHtml(String(labelStr))}</div></div>
      <div class="row"><div class="k">value</div><div class="v">${escapeHtml(valStr)}</div></div>
    `;

    // Position above click, clamp to viewport
    const x = (clickPos && isFinite(clickPos.x)) ? clickPos.x : (lastMouseClient?.x ?? 20);
    const y = (clickPos && isFinite(clickPos.y)) ? clickPos.y : (lastMouseClient?.y ?? 20);

    watchPopup.hidden = false;
    watchPopupOpen = true;

    // measure after display
    requestAnimationFrame(() => {
      const rect = watchPopup.getBoundingClientRect();
      let left = x - rect.width * 0.5;
      let top = y - rect.height - 10;

      left = clamp(left, 8, window.innerWidth - rect.width - 8);
      if (top < 8) top = clamp(y + 10, 8, window.innerHeight - rect.height - 8);

      watchPopup.style.left = `${left}px`;
      watchPopup.style.top = `${top}px`;
    });
  }

  // dismiss by clicking anywhere else
  document.addEventListener('mousedown', (e) => {
    if (!watchPopupOpen) return;
    if (watchPopup && watchPopup.contains(e.target)) return;
    hideWatchPopup();
  }, { capture: true });


  function renderWatchList() {
    watchList.innerHTML = "";
    watchCount.textContent = `${watchMarkers.length}`;

    const mode = watchSort ? watchSort.value : "time";
    const items = watchMarkers.slice();

    const valKey = (v) => {
      if (v == null) return { t: 2, n: 0, s: "" };
      if (typeof v === "boolean") return { t: 0, n: v ? 1 : 0, s: String(v) };
      if (typeof v === "number") return { t: 1, n: v, s: "" };
      return { t: 0, n: 0, s: String(v) };
    };

    items.sort((a,b) => {
      const wa = a.watch || {};
      const wb = b.watch || {};
      if (mode === "level") return String(wa.level||"").localeCompare(String(wb.level||""));
      if (mode === "time") return (a.t ?? 0) - (b.t ?? 0);
      if (mode === "-time") return (b.t ?? 0) - (a.t ?? 0);
      if (mode === "value") {
        const ka = valKey(wa.value);
        const kb = valKey(wb.value);
        if (ka.t !== kb.t) return ka.t - kb.t;
        if (ka.t === 1) return (ka.n - kb.n);
        return ka.s.localeCompare(kb.s);
      }
      return 0;
    });

    for (const m of items) {
      const w = m.watch;
      const st = levelStyle(w.level);
      const label = w.label || "";
      const value = w.value ?? "";
      const t = m.t;

      const div = document.createElement("div");
      div.className = "watchItem";
      div.dataset.t = String(t);

      div.innerHTML = `
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap">
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <span class="pill level" style="background:${st.fill};color:${st.text}">${escapeHtml(st.name)}</span>
            <span style="font-weight:850;word-break:break-word">${escapeHtml(label)}</span>
          </div>
          <div class="muted">${t != null ? (t + "ms") : ""}</div>
        </div>
        <div class="bigValue">${escapeHtml(String(value))}</div>
      `;

      div.addEventListener('click', (ev) => selectWatchMarker(m, true, { x: ev.clientX, y: ev.clientY }));
      watchList.appendChild(div);
    }

    if (selectedWatch?.marker?.t != null) highlightWatchInList(selectedWatch.marker.t, false);
  }

  function selectWatchMarker(marker, fromUserClick=false, clickPos=null) {
    selectedWatch = { marker };

    // clicking a watch should override track lock/hover to avoid confusion
    clearTrackHover(true);
    clearTrackLock();

    const near = nearestIndexWithinTol(marker.t, WATCH_TOL_MS);
    if (near) {
      selectedIndex = near.idx;
      setStatus(`Watch @${marker.t}ms mapped to pose @${rawPoses[near.idx].t}ms (Î”=${near.dt}ms).`);
    } else {
      selectedIndex = findFloorIndexByTime(marker.t);
      setStatus(`Watch @${marker.t}ms shown via interpolation (no pose within Â±${WATCH_TOL_MS}ms).`);
    }

    pause();
    hoverTimelineTime = null;
    timelineHoverSaved = null;

    highlightWatchInList(marker.t, fromUserClick);

    if (fromUserClick) {
      showWatchPopup(marker, clickPos);
    } else {
      hideWatchPopup();
    }
    highlightPoseInList();
    updatePoseReadout();
    requestDrawAll();
  }

  // -------- pose list --------
  function renderPoseList() {
    if (!poseList) return;
    poseList.innerHTML = "";
    if (!rawPoses.length) {
      poseCount.textContent = "â€”";
      return;
    }
    poseCount.textContent = `${rawPoses.length}`;
    const frag = document.createDocumentFragment();
    const maxItems = rawPoses.length; // keep simple
    for (let i=0; i<maxItems; i++) {
      const p = rawPoses[i];
      const t = (typeof p.t === "number") ? Math.round(p.t) : "â€”";
      const pi = poseToInches(p);
      const poseSummary = `X: ${(pi.x ?? 0).toFixed(1)}in, Y: ${(pi.y ?? 0).toFixed(1)}in, Î¸: ${(pi.theta ?? 0).toFixed(1)}Â°`;
      const div = document.createElement('div');
      div.className = 'poseItem';
      div.dataset.idx = String(i);
      div.innerHTML = `<div style="display:flex;justify-content:space-between;gap:10px">
        <div style="font-weight:800">#${i+1}</div>
        <div class="muted">${t}ms</div>
      </div>
      <div class="sub">${escapeHtml(poseSummary)}</div>`;
      div.addEventListener('click', () => {
        pause();
        clearTrackHover(true);
        clearTrackLock();
        selectedWatch = null;
        selectedIndex = i;
        setStatus(`Jumped to pose #${i+1}.`);
        highlightPoseInList();
        updatePoseReadout();
        requestDrawAll();
      });
      frag.appendChild(div);
    }
    poseList.appendChild(frag);
    highlightPoseInList();
  }

  function highlightPoseInList() {
    if (!poseList) return;
    const els = poseList.querySelectorAll('.poseItem');
    els.forEach(el => el.classList.toggle('selected', Number(el.dataset.idx) === selectedIndex));
    const el = poseList.querySelector(`.poseItem[data-idx="${CSS.escape(String(selectedIndex))}"]`);
    if (el) el.scrollIntoView({ block: "nearest" });
  }

  // -------- drawing --------
  let drawQueued = false;
  function requestDrawAll() {
    if (drawQueued) return;
    drawQueued = true;
    requestAnimationFrame(() => {
      drawQueued = false;
      draw();
      drawTimeline();
    });
  }

  function drawField() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "#0b0f14";
    ctx.fillRect(0, 0, w, h);

    if (!fieldImg) return;
    const p0 = worldToScreen(bounds.minX, bounds.minY);
    const p1 = worldToScreen(bounds.maxX, bounds.maxY);
    const left = Math.min(p0.x, p1.x);
    const top = Math.min(p0.y, p1.y);
    const right = Math.max(p0.x, p1.x);
    const bottom = Math.max(p0.y, p1.y);

    ctx.globalAlpha = 0.95;
    ctx.drawImage(fieldImg, left, top, right - left, bottom - top);
    ctx.globalAlpha = 1.0;
  }

  function drawAxes() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const o = worldToScreen(0, 0);
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0, o.y); ctx.lineTo(w, o.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(o.x, 0); ctx.lineTo(o.x, h); ctx.stroke();
  }

  function drawPath() {
    const poses = getPosesInches();
    if (poses.length < 2) return;
    for (let i = 1; i < poses.length; i++) {
      const a = poses[i-1], b = poses[i];
      const pa = worldToScreen(a.x, a.y);
      const pb = worldToScreen(b.x, b.y);
      const grad = ctx.createLinearGradient(pa.x, pa.y, pb.x, pb.y);
      grad.addColorStop(0, heatColorFromNorm(a.speed_norm ?? 0));
      grad.addColorStop(1, heatColorFromNorm(b.speed_norm ?? 0));
      ctx.strokeStyle = grad;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y);
      ctx.lineTo(pb.x, pb.y);
      ctx.stroke();
    }
  }

  function drawWatchDots() {
    if (!watchMarkers.length) return;

    for (const m of watchMarkers) {
      const { pose, watch } = m;
      if (!pose) continue;
      const st = levelStyle(watch.level);
      const p = worldToScreen(pose.x, pose.y);

      const isHover = (hoverWatch === m);
      const r = isHover ? 5.6 : 4.2;
      const fillA = isHover ? 0.40 : 0.25;

      ctx.save();
      ctx.fillStyle = st.fill.replace("rgb(", "rgba(").replace(")", `,${fillA})`);
      ctx.strokeStyle = "rgba(255,255,255,0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    if (selectedWatch?.marker?.pose) {
      const st = levelStyle(selectedWatch.marker.watch.level);
      const pose = selectedWatch.marker.pose;
      const p = worldToScreen(pose.x, pose.y);

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 9.0, 0, Math.PI*2);
      ctx.stroke();

      ctx.fillStyle = st.fill.replace("rgb(", "rgba(").replace(")", ",0.35)");
      ctx.beginPath();
      ctx.arc(p.x, p.y, 6.5, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawRobot(pose, alpha=1.0) {
    if (!pose) return;
    const { w: wIn, h: hIn } = robotDimsInches();
    const center = worldToScreen(pose.x, pose.y);
    const wPx = wIn * scale;
    const hPx = hIn * scale;
    const thetaDeg = (pose.theta ?? 0);
    const thetaRad = (thetaDeg) * Math.PI / 180;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(center.x, center.y);
    ctx.rotate(thetaRad);

    ctx.fillStyle = "rgba(255,255,255,0.14)";
    ctx.strokeStyle = "rgba(255,255,255,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(-wPx/2, -hPx/2, wPx, hPx);
    ctx.fill();
    ctx.stroke();

    ctx.strokeStyle = "rgba(255,255,255,0.98)";
    ctx.beginPath();
    ctx.moveTo(wPx/2, -hPx/2);
    ctx.lineTo(wPx/2,  hPx/2);
    ctx.stroke();

    const arrowLen = Math.max(wPx, hPx) * 0.85;
    ctx.strokeStyle = "rgba(255,255,255,0.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(arrowLen/2, 0);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(arrowLen/2, 0);
    ctx.lineTo(arrowLen/2 - 8, -5);
    ctx.lineTo(arrowLen/2 - 8,  5);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.fill();

    ctx.restore();
  }

  function currentDisplayPose() {
    // priority:
    // playing > timeline hover > track hover > track lock > selectedIndex
    if (playing) return playPose || interpolatePoseAtTime(playTimeMs);
    if (!playing && hoverTimelineTime != null) return interpolatePoseAtTime(hoverTimelineTime);
    if (!playing && !trackLockActive && trackHover?.pose) return trackHover.pose;
    if (!playing && trackLockActive && trackLockPose) return trackLockPose;
    const poses = getPosesInches();
    return poses[selectedIndex] || null;
  }

  function draw() {
    drawField();
    drawAxes();
    drawPath();
    drawWatchDots();

    const p = currentDisplayPose();
    if (p) drawRobot(p, 1.0);
  }

    // -------- timeline --------
  function indexToX(i) {
    const rect = timelineCanvas.getBoundingClientRect();
    const W = rect.width || 1;
    const n = Math.max(1, rawPoses.length - 1);
    return (clamp(i, 0, n) / n) * W;
  }

  // Map a time to a *fractional pose index*, then to X.
  // This makes consecutive poses evenly spaced on the timeline.
  function timeToX(t) {
    if (!rawPoses.length) return 0;

    // binary search for floor index by time
    let lo = 0, hi = rawPoses.length - 1;
    while (lo < hi) {
      const mid = (lo + hi + 1) >> 1;
      const tm = rawPoses[mid]?.t ?? 0;
      if (tm <= t) lo = mid;
      else hi = mid - 1;
    }

    const i0 = lo;
    const i1 = Math.min(rawPoses.length - 1, i0 + 1);
    const t0 = rawPoses[i0]?.t ?? 0;
    const t1 = rawPoses[i1]?.t ?? t0;

    const frac = (t1 === t0) ? 0 : clamp((t - t0) / (t1 - t0), 0, 1);
    return indexToX(i0 + frac);
  }

  // Inverse: X -> fractional pose index -> interpolated time
  function xToTime(x) {
    if (!rawPoses.length) return 0;

    const rect = timelineCanvas.getBoundingClientRect();
    const W = rect.width || 1;

    const a = clamp(x / W, 0, 1);
    const f = a * (rawPoses.length - 1);

    const i0 = Math.floor(f);
    const i1 = Math.min(rawPoses.length - 1, i0 + 1);
    const frac = f - i0;

    const t0 = rawPoses[i0]?.t ?? 0;
    const t1 = rawPoses[i1]?.t ?? t0;
    return t0 + frac * (t1 - t0);
  }

  function timelinePickWatchDot(mx, my) {
    const r = 8;
    for (const m of watchMarkers) {
      const dx = mx - timeToX(m.t);
      const dy = my - 10;
      if ((dx*dx + dy*dy) <= r*r) return m;
    }
    return null;
  }

  function drawTimeline() {
    if (timelineBar.classList.contains('isCollapsed')) return;

    const rect = timelineCanvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;
    tctx.clearRect(0, 0, W, H);

    tctx.fillStyle = "rgba(16,23,32,0.55)";
    tctx.fillRect(0, 0, W, H);

    if (!rawPoses.length) return;
    const range = timeRange();
    if (!range) return;

    tctx.strokeStyle = "rgba(255,255,255,0.08)";
    tctx.lineWidth = 1;
    const major = 10;
    for (let i=0; i<=major; i++) {
      const x = (W * i) / major;
      tctx.beginPath(); tctx.moveTo(x, 0); tctx.lineTo(x, H); tctx.stroke();
    }

    // speed trace using norm
    tctx.lineWidth = 2;
    for (let i=1; i<rawPoses.length; i++) {
      const a = rawPoses[i-1], b = rawPoses[i];
      if (typeof a.t !== "number" || typeof b.t !== "number") continue;

      const xa = timeToX(a.t);
      const xb = timeToX(b.t);

      const ya = H - 6 - (clamp(a.speed_norm ?? 0, 0, 1) * (H - 12));
      const yb = H - 6 - (clamp(b.speed_norm ?? 0, 0, 1) * (H - 12));

      const grad = tctx.createLinearGradient(xa, ya, xb, yb);
      grad.addColorStop(0, heatColorFromNorm(a.speed_norm ?? 0));
      grad.addColorStop(1, heatColorFromNorm(b.speed_norm ?? 0));

      tctx.strokeStyle = grad;
      tctx.beginPath();
      tctx.moveTo(xa, ya);
      tctx.lineTo(xb, yb);
      tctx.stroke();
    }

    // watch dots
    for (const m of watchMarkers) {
      const st = levelStyle(m.watch.level);
      const x = timeToX(m.t);
      const y = 10;
      tctx.save();
      tctx.fillStyle = st.fill.replace("rgb(", "rgba(").replace(")", ",0.25)");
      tctx.strokeStyle = "rgba(255,255,255,0.95)";
      tctx.lineWidth = 2;
      tctx.beginPath();
      tctx.arc(x, y, 4.2, 0, Math.PI*2);
      tctx.fill();
      tctx.stroke();
      tctx.restore();
    }

    // selected marker: depends on current state
    let selT = null;
    if (playing) selT = playTimeMs;
    else if (trackLockActive && trackLockIndex != null) selT = rawPoses[trackLockIndex]?.t ?? null;
    else selT = rawPoses[selectedIndex]?.t ?? null;

    if (selT != null) {
      const x = timeToX(selT);
      tctx.strokeStyle = "rgba(255,255,255,0.95)";
      tctx.lineWidth = 2;
      tctx.beginPath();
      tctx.moveTo(x, 0);
      tctx.lineTo(x, H);
      tctx.stroke();
    }

    if (hoverTimelineTime != null) {
      const x = timeToX(hoverTimelineTime);
      tctx.strokeStyle = "rgba(255,255,255,0.5)";
      tctx.lineWidth = 1.5;
      tctx.beginPath();
      tctx.moveTo(x, 0);
      tctx.lineTo(x, H);
      tctx.stroke();
    }

    if (selectedWatch?.marker?.t != null) {
      const x = timeToX(selectedWatch.marker.t);
      const y = 10;
      tctx.save();
      tctx.strokeStyle = "rgba(255,255,255,0.95)";
      tctx.lineWidth = 2;
      tctx.beginPath();
      tctx.arc(x, y, 9.0, 0, Math.PI*2);
      tctx.stroke();
      tctx.restore();
    }
  }

  // -------- pose readout --------
  function updatePoseReadout() {
    if (!data || !rawPoses.length) {
      timePill.textContent = "Time: â€”";
      pointPill.textContent = "Point: â€”/â€”";
      posePill.textContent = "X: â€”  Y: â€” Î¸: â€”  Speed: â€”";
      return;
    }

    let idx = selectedIndex;
    let t = rawPoses[idx]?.t ?? null;
    let p = null;

    if (playing) {
      t = playTimeMs;
      idx = findFloorIndexByTime(playTimeMs);
      p = interpolatePoseAtTime(playTimeMs);
    } else if (hoverTimelineTime != null) {
      t = hoverTimelineTime;
      idx = findFloorIndexByTime(hoverTimelineTime);
      p = interpolatePoseAtTime(hoverTimelineTime);
    } else if (!playing && !trackLockActive && trackHover?.pose) {
      p = trackHover.pose;
      // approximate index for readout
      idx = trackHover.idxNearest ?? selectedIndex;
      t = rawPoses[idx]?.t ?? null;
    } else if (!playing && trackLockActive && trackLockPose) {
      p = trackLockPose;
      idx = trackLockIndex ?? selectedIndex;
      t = rawPoses[idx]?.t ?? null;
    } else {
      p = poseToInches(rawPoses[idx]);
    }

    const total = rawPoses.length;
    timePill.textContent = (t == null) ? "Time: â€”" : `Time: ${Math.round(t)}ms`;
    pointPill.textContent = `Point: ${Math.max(1, idx+1)}/${total}`;

    const spRaw = (p?.speed_raw != null) ? p.speed_raw : (rawPoses[idx]?.speed_raw ?? null);
    const spNorm = (p?.speed_norm != null) ? p.speed_norm : (rawPoses[idx]?.speed_norm ?? 0);

    posePill.textContent = p
      ? `X: ${fmtNum(p.x,1)}  Y: ${fmtNum(p.y,1)}  Î¸: ${fmtNum(p.theta,1)}Â°  Speed: ${fmtNum(spRaw,2)} (n=${fmtNum(spNorm,2)})`
      : "X: â€”  Y: â€”  Î¸: â€”  Speed: â€”";
  }

  // -------- fit --------
  function fitToPoses() {
    const poses = getPosesInches();
    if (!poses.length) return;
    let minX = poses[0].x, maxX = poses[0].x;
    let minY = poses[0].y, maxY = poses[0].y;
    for (const p of poses) {
      minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
      minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
    }
    const margin = 6;
    bounds.minX = minX - margin; bounds.maxX = maxX + margin;
    bounds.minY = minY - margin; bounds.maxY = maxY + margin;
    bounds.pad = FIELD_BOUNDS_IN.pad;
    computeTransform();
    requestDrawAll();
  }

  // -------- track hover/lock --------
  function pickTrackPose(clientX, clientY) {
    if (!rawPoses.length) return null;
    const rect = canvas.getBoundingClientRect();
    const mx = clientX - rect.left;
    const my = clientY - rect.top;

    const poses = getPosesInches();
    if (poses.length < 2) return null;

    let best = { dist2: Infinity, i: -1, alpha: 0 };

    for (let i = 0; i < poses.length - 1; i++) {
      const a = poses[i], b = poses[i+1];
      const pa = worldToScreen(a.x, a.y);
      const pb = worldToScreen(b.x, b.y);

      const vx = pb.x - pa.x, vy = pb.y - pa.y;
      const wx = mx - pa.x, wy = my - pa.y;
      const vv = vx*vx + vy*vy || 1;
      let alpha = (wx*vx + wy*vy) / vv;
      alpha = clamp(alpha, 0, 1);

      const px = pa.x + alpha*vx;
      const py = pa.y + alpha*vy;
      const dx = mx - px, dy = my - py;
      const d2 = dx*dx + dy*dy;

      if (d2 < best.dist2) best = { dist2: d2, i, alpha };
    }

    const dist = Math.sqrt(best.dist2);
    if (dist > HOVER_PIXEL_TOL) return null;

    const i0 = best.i, i1 = best.i + 1;
    const p0 = poses[i0], p1 = poses[i1];
    const a = best.alpha;

    const pose = {
      t: null,
      x: p0.x + (p1.x - p0.x) * a,
      y: p0.y + (p1.y - p0.y) * a,
      theta: angLerpDeg(p0.theta ?? 0, p1.theta ?? 0, a),
      l_vel: (p0.l_vel ?? 0) + ((p1.l_vel ?? 0) - (p0.l_vel ?? 0)) * a,
      r_vel: (p0.r_vel ?? 0) + ((p1.r_vel ?? 0) - (p0.r_vel ?? 0)) * a,
      speed_raw: (p0.speed_raw ?? 0) + ((p1.speed_raw ?? 0) - (p0.speed_raw ?? 0)) * a,
      speed_norm: (p0.speed_norm ?? 0) + ((p1.speed_norm ?? 0) - (p0.speed_norm ?? 0)) * a,
    };

    // nearest index to this segment position
    const nearestIdx = (a < 0.5) ? i0 : i1;
    return { pose, nearestIdx };
  }

  function clearTrackHover(restore) {
    trackHover = null;
    if (restore && trackHoverSavedIndex != null) {
      selectedIndex = trackHoverSavedIndex;
      trackHoverSavedIndex = null;
    }
  }

  function clearTrackLock() {
    trackLockActive = false;
    trackLockPose = null;
    trackLockIndex = null;
  }

  // -------- watch hit test on field --------
  function hitTestWatchAtClient(clientX, clientY) {
    if (!watchMarkers.length) return null;
    const rect = canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    const tol = 10;
    let best = null;
    let bestD2 = tol*tol;
    for (const m of watchMarkers) {
      if (!m.pose) continue;
      const p = worldToScreen(m.pose.x, m.pose.y);
      const dx = p.x - x;
      const dy = p.y - y;
      const d2 = dx*dx + dy*dy;
      if (d2 <= bestD2) { bestD2 = d2; best = m; }
    }
    return best;
  }

  // -------- playback --------
  let playPose = null;

  function pause() {
    playing = false;
    btnPlay.textContent = "â–¶";
    if (raf) cancelAnimationFrame(raf);
    raf = null;
    playPose = null;
    lastWall = null;
  }

  function play() {
    if (!rawPoses.length) return;

    // starting playback clears track lock to avoid confusing states
    clearTrackHover(true);
    clearTrackLock();
    selectedWatch = null;

    const tStart = rawPoses[selectedIndex]?.t;
    playTimeMs = (typeof tStart === "number") ? tStart : (rawPoses[0]?.t ?? 0);

    playing = true;
    btnPlay.textContent = "â¸";
    lastWall = performance.now();

    const tick = (now) => {
      if (!playing) return;
      const dtWall = now - lastWall;
      lastWall = now;
      // Make playback speed match the heat color scale (slow=red, fast=green),
      // including when the user adjusts Min/Max speed normalization.
      const cur = interpolatePoseAtTime(playTimeMs) || rawPoses[selectedIndex] || null;
      const n = (cur && typeof cur.speed_norm === "number") ? cur.speed_norm : 0.5;
      const SPEED_SLOW = 0.25; // red end
      const SPEED_FAST = 2.00; // green end
      const speedFactor = SPEED_SLOW + (SPEED_FAST - SPEED_SLOW) * clamp(n, 0, 1);
      playTimeMs += dtWall * playRate * speedFactor;

      const tMin = rawPoses[0]?.t ?? 0;
      const tMax = rawPoses[rawPoses.length - 1]?.t ?? tMin;

      if (playTimeMs >= tMax) {
        playTimeMs = tMax;
        playPose = interpolatePoseAtTime(playTimeMs);
        selectedIndex = rawPoses.length - 1;
        updatePoseReadout();
        requestDrawAll();
        pause();
        return;
      }

      playPose = interpolatePoseAtTime(playTimeMs);
      selectedIndex = findFloorIndexByTime(playTimeMs);

      // Auto-open Watches and highlight the most recent watch hit
      const last = lastWatchAtTime(playTimeMs);
      if (last && (!selectedWatch || selectedWatch.marker?.t !== last.t)) {
        selectedWatch = { marker: last };
        // open Watches panel during playback
        if (secWatches) secWatches.open = true;
        highlightWatchInList(last.t, false);
      }

      updatePoseReadout();
      requestDrawAll();
      raf = requestAnimationFrame(tick);
    };

    raf = requestAnimationFrame(tick);
  }

  // -------- timeline interactions --------
  function timelineMousePos(e) {
    const rect = timelineCanvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  timelineCanvas.addEventListener("mousemove", (e) => {
    if (!data || playing || !rawPoses.length) return;

    const { x, y } = timelineMousePos(e);
    const hit = timelinePickWatchDot(x, y);
    timelineCanvas.style.cursor = hit ? "pointer" : "crosshair";

    if (timelineHoverSaved == null) {
      timelineHoverSaved = {
        index: selectedIndex,
        lockActive: trackLockActive,
        lockPose: trackLockPose,
        lockIndex: trackLockIndex
      };
    }

    // timeline hover always previews, even if track lock is active
    hoverTimelineTime = xToTime(x);
    updatePoseReadout();
    requestDrawAll();
  });

  timelineCanvas.addEventListener("mouseleave", () => {
    if (!data || playing) return;
    hoverTimelineTime = null;
    timelineCanvas.style.cursor = "default";

    if (timelineHoverSaved != null) {
      selectedIndex = timelineHoverSaved.index;
      trackLockActive = timelineHoverSaved.lockActive;
      trackLockPose = timelineHoverSaved.lockPose;
      trackLockIndex = timelineHoverSaved.lockIndex;
      timelineHoverSaved = null;
    }

    updatePoseReadout();
    requestDrawAll();
  });

  timelineCanvas.addEventListener("mousedown", (e) => {
    if (!data || playing || !rawPoses.length) return;
    const { x, y } = timelineMousePos(e);

    const hit = timelinePickWatchDot(x, y);
    if (hit) {
      selectWatchMarker(hit, true, { x: e.clientX, y: e.clientY });
      return;
    }

    // lock selection at time (clears track lock)
    clearTrackHover(true);
    clearTrackLock();
    selectedWatch = null;

    const t = xToTime(x);
    selectedIndex = findFloorIndexByTime(t);
    hoverTimelineTime = null;
    timelineHoverSaved = null;

    highlightPoseInList();
    updatePoseReadout();
    requestDrawAll();
  });

  // -------- field interactions --------
  canvas.addEventListener('mousemove', (e) => {
    if (!data || playing || hoverTimelineTime != null) return;

    // watch hover has priority
    const hw = hitTestWatchAtClient(e.clientX, e.clientY);
    if (hw) {
      hoverWatch = hw;
      canvas.style.cursor = "pointer";
      requestDrawAll();
      return;
    } else {
      if (hoverWatch) { hoverWatch = null; requestDrawAll(); }
      canvas.style.cursor = "";
    }

    // if locked, ignore hover preview
    if (trackLockActive) return;

    const hit = pickTrackPose(e.clientX, e.clientY);
    if (!hit) {
      if (trackHover) {
        clearTrackHover(true);
        highlightPoseInList();
        updatePoseReadout();
        requestDrawAll();
      }
      return;
    }

    if (trackHoverSavedIndex == null) trackHoverSavedIndex = selectedIndex;
    trackHover = { pose: hit.pose, idxNearest: hit.nearestIdx };
    updatePoseReadout();
    requestDrawAll();
  });

  canvas.addEventListener('mouseleave', () => {
    hoverWatch = null;
    canvas.style.cursor = "";
    if (!trackLockActive && trackHover) {
      clearTrackHover(true);
      highlightPoseInList();
      updatePoseReadout();
      requestDrawAll();
    }
  });

  canvas.addEventListener('click', (e) => {
    if (!data || playing) return;

    const hw = hitTestWatchAtClient(e.clientX, e.clientY);
    if (hw) {
      selectWatchMarker(hw, true, { x: e.clientX, y: e.clientY });
      return;
    }

    const hit = pickTrackPose(e.clientX, e.clientY);
    if (hit) {
      // lock to clicked position
      pause();
      selectedWatch = null;

      trackLockActive = true;
      trackLockPose = hit.pose;
      trackLockIndex = hit.nearestIdx;

      selectedIndex = hit.nearestIdx;
      clearTrackHover(false);
      trackHoverSavedIndex = null;

      setStatus(`Locked to track near pose #${selectedIndex+1}. (Click off-track to unlock)`);
      highlightPoseInList();
      updatePoseReadout();
      requestDrawAll();
      return;
    }

    // click off-track unlocks
    if (trackLockActive) {
      clearTrackLock();
      setStatus(`Unlocked track lock.`);
      updatePoseReadout();
      requestDrawAll();
    }
  });

  // -------- splitters with collapse --------
  (function setupSplitters() {
    let draggingV = false;
    let startX = 0;
    let startW = 0;

    let lastSidebarW = 360;

    const getSidebarW = () => {
      const v = getComputedStyle(root).getPropertyValue('--sidebarW').trim();
      const n = parseFloat(v);
      return isFinite(n) ? n : 360;
    };
    const setSidebarW = (px) => root.style.setProperty('--sidebarW', `${px}px`);

    vSplit.addEventListener('mousedown', (e) => {
      draggingV = true;
      startX = e.clientX;
      startW = getSidebarW();
      document.body.style.cursor = 'col-resize';
      e.preventDefault();
    });

    let draggingH = false;
    let startY = 0;
    let startH = 0;
    let lastTimelineH = 260;

    const getTimelineH = () => {
      const v = getComputedStyle(root).getPropertyValue('--timelineH').trim();
      const n = parseFloat(v);
      return isFinite(n) ? n : 260;
    };
    const setTimelineH = (px) => root.style.setProperty('--timelineH', `${px}px`);

    hSplit.addEventListener('mousedown', (e) => {
      draggingH = true;
      startY = e.clientY;
      startH = getTimelineH();
      document.body.style.cursor = 'row-resize';
      e.preventDefault();
    });

    window.addEventListener('mousemove', (e) => {
      if (draggingV) {
        const dx = e.clientX - startX;
        const w = window.innerWidth;
        let next = clamp(startW - dx, 0, Math.max(0, w - 240));

        if (next <= COLLAPSE_PX) {
          next = 0;
          rightEl.classList.add('isCollapsed');
        } else {
          rightEl.classList.remove('isCollapsed');
          lastSidebarW = next;
        }
        setSidebarW(next);
        resizeCanvas();
        resizeTimeline();
      }

      if (draggingH) {
        const dy = e.clientY - startY;
        const h = window.innerHeight;
        let next = clamp(startH - dy, 0, Math.max(0, Math.floor(h * 0.80)));

        if (next <= COLLAPSE_PX) {
          next = 0;
          timelineBar.classList.add('isCollapsed');
        } else {
          timelineBar.classList.remove('isCollapsed');
          lastTimelineH = next;
        }
        setTimelineH(next);
        resizeTimeline();
        resizeCanvas();
      }
    });

    window.addEventListener('mouseup', () => {
      if (draggingV || draggingH) {
        draggingV = false;
        draggingH = false;
        document.body.style.cursor = '';
        // If user re-expands from collapsed by dragging, restore visibility automatically
        if (getSidebarW() > COLLAPSE_PX) rightEl.classList.remove('isCollapsed');
        if (getTimelineH() > COLLAPSE_PX) timelineBar.classList.remove('isCollapsed');
        resizeCanvas();
        resizeTimeline();
      }
    });

    // double-click splitters to toggle collapse/restore
    vSplit.addEventListener('dblclick', () => {
      const cur = getSidebarW();
      if (cur <= COLLAPSE_PX) {
        setSidebarW(Math.max(240, lastSidebarW));
        rightEl.classList.remove('isCollapsed');
      } else {
        lastSidebarW = cur;
        setSidebarW(0);
        rightEl.classList.add('isCollapsed');
      }
      resizeCanvas(); resizeTimeline();
    });

    hSplit.addEventListener('dblclick', () => {
      const cur = getTimelineH();
      if (cur <= COLLAPSE_PX) {
        setTimelineH(Math.max(160, lastTimelineH));
        timelineBar.classList.remove('isCollapsed');
      } else {
        lastTimelineH = cur;
        setTimelineH(0);
        timelineBar.classList.add('isCollapsed');
      }
      resizeTimeline(); resizeCanvas();
    });
  })();

  // -------- data load --------
  function setData(obj) {
    data = obj;
    if (!obj || !Array.isArray(obj.poses)) {
      setStatus("Invalid viewer JSON: missing poses[]");
      return;
    }

    rawPoses = obj.poses
      .filter(p => p && typeof p.x === "number" && typeof p.y === "number")
      .map(p => ({
        t: (typeof p.t === "number") ? p.t : (toNumMaybe(p.t) ?? null),
        x: p.x, y: p.y,
        theta: (typeof p.theta === "number") ? p.theta : (toNumMaybe(p.theta) ?? 0),
        l_vel: (typeof p.l_vel === "number") ? p.l_vel : (toNumMaybe(p.l_vel) ?? null),
        r_vel: (typeof p.r_vel === "number") ? p.r_vel : (toNumMaybe(p.r_vel) ?? null),
        speed_raw: (typeof p.speed === "number") ? p.speed : (toNumMaybe(p.speed) ?? 0),
        speed_norm: 0,
      }))
      .sort((a,b) => (a.t ?? 0) - (b.t ?? 0));

    // watches: accept alternate key just in case
    watches = normalizeWatches(obj.watches || obj.watch || obj.events || []);

    const inferred = inferUnitsFromMeta(obj?.meta?.units);
    unitsSelect.value = inferred;
    setUnitsFactorFromSelect(inferred);

    const rw = obj?.meta?.robot?.width;
    const rh = obj?.meta?.robot?.height;
    robotWEl.value = (typeof rw === "number" && isFinite(rw)) ? String(rw) : "12";
    robotHEl.value = (typeof rh === "number" && isFinite(rh)) ? String(rh) : "12";

    offXEl.value = "0";
    offYEl.value = "0";
    offThetaEl.value = "0";
    updateOffsetsFromInputs();

    computeSpeedNorm();

    fmt.textContent = `${obj.format || "unknown"} v${obj.version ?? "?"}`;
    runName.textContent = obj?.meta?.run_name || "â€”";
    runMeta.textContent = `${obj?.meta?.coord_system || "â€”"} â€¢ Log Hz=${obj?.meta?.log_hz ?? "â€”"}`;

    selectedWatch = null;
    selectedIndex = 0;
    hoverTimelineTime = null;
    timelineHoverSaved = null;
    hoverWatch = null;

    clearTrackHover(true);
    clearTrackLock();
    pause();

    recomputeWatchMarkers();
    rebuildWatchMarkersByTime();
    renderWatchList();
    renderPoseList();

    // stats
    const th = obj.thinning || {};
    const t0 = rawPoses[0]?.t;
    const tN = rawPoses[rawPoses.length-1]?.t;
    const rows = [
      ["poses(file)", rawPoses.length],
      ["watches(file)", watches.length],
      ["watches(mapped)", watchMarkers.length],
      ["file raw est", th.raw ?? "â€”"],
      ["file kept", th.kept ?? "â€”"],
      ["file removed", th.removed ?? "â€”"],
      ["viewer_thin_ms", th.viewer_thin_ms ?? "â€”"],
      ["t range", (typeof t0==="number" && typeof tN==="number") ? `${t0}â€¦${tN} ms` : "â€”"],
    ];
    statsEl.innerHTML = "";
    for (const [k, v] of rows) {
      const a = document.createElement("div"); a.textContent = k;
      const b = document.createElement("div"); b.textContent = String(v);
      statsEl.appendChild(a); statsEl.appendChild(b);
    }

    bounds = { ...FIELD_BOUNDS_IN };
    computeTransform();

    setStatus(`Loaded ${rawPoses.length} poses, ${watches.length} watches.`);
    btnPlay.disabled = rawPoses.length < 2;
    btnFit.disabled = rawPoses.length < 2;
    fieldSelect.disabled = false;

    updatePoseReadout();
    requestDrawAll();
  }

  async function handleFile(file) {
    try {
      const text = await file.text();
      const obj = JSON.parse(text);
      setData(obj);
    } catch (e) {
      console.error(e);
      setStatus(`Failed to load: ${e?.message || e}`);
    }
  }

  // -------- controls wiring --------
  btnFile.addEventListener('click', () => fileEl.click());
  fileEl.addEventListener('change', (e) => {
    const file = e.target.files?.[0];
    if (file) handleFile(file);
  });


  // Help modal
  function openHelp() {
    if (!helpModal) return;
    helpModal.hidden = false;
  }
  function closeHelp() {
    if (!helpModal) return;
    helpModal.hidden = true;
  }
  if (btnHelp) btnHelp.addEventListener('click', openHelp);
  if (btnHelpClose) btnHelpClose.addEventListener('click', closeHelp);
  if (helpModal) {
    helpModal.addEventListener('click', (e) => {
      if (e.target && (e.target.classList.contains('modalBackdrop'))) closeHelp();
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !helpModal.hidden) closeHelp();
    });
  }

  document.addEventListener('dragover', (e) => { e.preventDefault(); });
  document.addEventListener('drop', (e) => {
    e.preventDefault();
    const file = e.dataTransfer?.files?.[0];
    if (file) handleFile(file);
  });


  // Help modal
  function openHelp() {
    if (!helpModal) return;
    helpModal.hidden = false;
  }
  function closeHelp() {
    if (!helpModal) return;
    helpModal.hidden = true;
  }
  if (btnHelp) btnHelp.addEventListener('click', openHelp);
  if (btnHelpClose) btnHelpClose.addEventListener('click', closeHelp);
  if (helpModal) {
    helpModal.addEventListener('click', (e) => {
      if (e.target && (e.target.classList.contains('modalBackdrop'))) closeHelp();
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !helpModal.hidden) closeHelp();
    });
  }

  btnPlay.addEventListener('click', () => {
    if (!data) return;
    if (playing) { pause(); updatePoseReadout(); requestDrawAll(); }
    else play();
  });

  speedSelect.addEventListener('change', () => {
    playRate = Number(speedSelect.value) || 1;
  });

  btnFit.addEventListener('click', () => fitToPoses());

  fieldSelect.addEventListener('change', (e) => loadFieldImage(e.target.value));

  unitsSelect.addEventListener('change', (e) => {
    setUnitsFactorFromSelect(e.target.value);
    updateOffsetsFromInputs();
    requestDrawAll();
  });

  robotWEl.addEventListener('input', () => requestDrawAll());
  robotHEl.addEventListener('input', () => requestDrawAll());

  minSpeedEl.addEventListener('input', () => { computeSpeedNorm(); recomputeWatchMarkers(); rebuildWatchMarkersByTime(); requestDrawAll(); updatePoseReadout(); });
  maxSpeedEl.addEventListener('input', () => { computeSpeedNorm(); recomputeWatchMarkers(); rebuildWatchMarkersByTime(); requestDrawAll(); updatePoseReadout(); });

  offXEl.addEventListener('input', updateOffsetsFromInputs);
  offYEl.addEventListener('input', updateOffsetsFromInputs);
  offThetaEl.addEventListener('input', updateOffsetsFromInputs);

  if (watchSort) watchSort.addEventListener('change', () => { renderWatchList(); requestDrawAll(); });

  document.addEventListener('keydown', (e) => {
    if (!data) return;
    if (e.code === "Space") {
      e.preventDefault();
      playing ? (pause(), updatePoseReadout(), requestDrawAll()) : play();
    }
    if (e.code === "ArrowLeft") {
      e.preventDefault();
      pause();
      clearTrackHover(true);
      clearTrackLock();
      selectedWatch = null;
      selectedIndex = Math.max(0, selectedIndex-1);
      highlightPoseInList();
      updatePoseReadout();
      requestDrawAll();
    }
    if (e.code === "ArrowRight") {
      e.preventDefault();
      pause();
      clearTrackHover(true);
      clearTrackLock();
      selectedWatch = null;
      selectedIndex = Math.min(rawPoses.length-1, selectedIndex+1);
      highlightPoseInList();
      updatePoseReadout();
      requestDrawAll();
    }
  });

  // -------- init --------
  loadFieldOptions();
  window.addEventListener('resize', () => { resizeCanvas(); resizeTimeline(); });
  resizeCanvas();
  resizeTimeline();
  drawFirstField();
})();
</script>
<div id="watchPopup" hidden></div>
</body>
</html>