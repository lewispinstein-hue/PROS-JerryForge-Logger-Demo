<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JerryForge Viewer (Offline)</title>
  <style>
    :root { --bg:#0b0f14; --panel:#101720; --text:#e7eef7; --muted:#93a4b8; --line:#233244; }
    * { box-sizing:border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:var(--bg); color:var(--text); }
    header { padding:10px 14px; border-bottom:1px solid var(--line); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header .grow { flex:1 1 auto; min-width: 180px; }
    button, select, input[type="file"], input[type="number"] {
      background:var(--panel); color:var(--text); border:1px solid var(--line);
      padding:8px 10px; border-radius:10px; max-width:100%;
    }
    button { cursor:pointer; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .muted { color:var(--muted); font-size:12px; }

    /* Layout: content row + bottom timeline */
    .app {
      height: calc(100vh - 56px);
      display:flex;
      flex-direction:column;
      min-height: 0;
    }
    .row {
      flex: 1 1 auto;
      display:flex;
      min-height:0;
      overflow:hidden;
    }
    #canvasWrap { flex:1 1 auto; position:relative; overflow:hidden; min-width: 0; }
    canvas#c { width:100%; height:100%; display:block; }

    /* Sidebar: flexible width, wraps content, no horizontal scroll */
    #right {
      flex: 0 0 clamp(260px, 26vw, 420px);
      border-left:1px solid var(--line);
      background:rgba(16,23,32,.7);
      backdrop-filter: blur(6px);
      overflow:auto;
      min-width: 240px;
    }
    #right * { min-width: 0; }
    #right .section { padding:12px 14px; border-bottom:1px solid var(--line); }
    .drop { border:1px dashed var(--line); border-radius:12px; padding:10px; }

    details { border: 1px solid var(--line); border-radius: 12px; overflow: hidden; background: rgba(16,23,32,.45); }
    details > summary {
      cursor: pointer;
      padding: 10px 12px;
      user-select: none;
      list-style: none;
      display:flex; align-items:center; justify-content:space-between;
      font-weight: 750;
      gap: 8px;
      flex-wrap: wrap;
    }
    details > summary::-webkit-details-marker { display:none; }
    .detailsBody { padding: 10px 12px; border-top:1px solid var(--line); }

    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--line); font-size:12px; color:var(--muted); white-space:nowrap; }
    .pill.level { border-color: transparent; color: #081018; font-weight: 800; }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .grid3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
    @media (max-width: 980px) {
      #right { flex-basis: 320px; }
      .grid3 { grid-template-columns: 1fr 1fr; }
    }
    @media (max-width: 740px) {
      .row { flex-direction:column; }
      #right { flex: 0 0 auto; max-height: 44vh; border-left:none; border-top:1px solid var(--line); }
    }

    label { font-size:12px; color:var(--muted); display:block; margin-bottom:4px; }

    #watchList { max-height: 40vh; overflow:auto; border:1px solid var(--line); border-radius:10px; }
    .watchItem { padding:10px 10px; border-bottom:1px solid var(--line); cursor:pointer; overflow:hidden; }
    .watchItem:hover { background: rgba(255,255,255,.04); }
    .watchItem:last-child { border-bottom:none; }
    .watchItem.selected { outline: 2px solid rgba(255,255,255,0.35); outline-offset:-2px; background: rgba(255,255,255,.03); }
    .bigValue { font-size: 15px; font-weight: 800; margin-top: 6px; word-break: break-word; }

    .kvs { display:grid; grid-template-columns: 1fr auto; gap:6px 10px; font-size:13px; }
    .kvs div:nth-child(2n) { color:var(--muted); text-align:right; }

    /* Bottom timeline */
    #timelineBar {
      flex: 0 0 96px;
      border-top:1px solid var(--line);
      background: rgba(8,12,18,0.95);
      display:flex;
      flex-direction:column;
      padding: 10px 12px;
      gap: 8px;
    }
    #timelineTop {
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
    }
    #timelineCanvas {
      width:100%;
      height: 54px;
      border:1px solid var(--line);
      border-radius: 12px;
      background: rgba(16,23,32,0.55);
      display:block;
    }
    #timelineHint { color: var(--muted); font-size: 12px; }
  
  :root{
    --sidebarW: 360px;
    --timelineH: 260px;
    --toolbarH: 54px;
  }
  header.toolbar{
    display:flex;
    align-items:center;
    gap:10px;
    padding:10px 12px;
    border-bottom:1px solid rgba(255,255,255,0.08);
    background: linear-gradient(180deg, rgba(8,14,22,0.92), rgba(8,14,22,0.80));
    position: sticky;
    top: 0;
    z-index: 50;
    height: var(--toolbarH);
    box-sizing: border-box;
  }
  .iconBtn{
    height: 34px;
    min-width: 38px;
    padding: 0 10px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.04);
    color: #e9eef7;
    font-size: 16px;
    cursor: pointer;
  }
  .iconBtn:disabled{ opacity:0.4; cursor:not-allowed; }
  .chip{
    display:flex;
    align-items:center;
    gap:8px;
    padding:6px 10px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.03);
    height: 34px;
    box-sizing: border-box;
  }
  .chip select{
    background: rgba(0,0,0,0.25);
    border: 1px solid rgba(255,255,255,0.12);
    color: inherit;
    border-radius: 10px;
    padding: 4px 8px;
    height: 24px;
  }
  .rowline{ display:flex; align-items:center; gap:10px; }
  .divider{ height:1px; background: rgba(255,255,255,0.10); }

  /* App layout with resizable sidebar + resizable timeline */
  .app{
    height: calc(100vh - var(--toolbarH));
    display: grid;
    grid-template-rows: 1fr 8px var(--timelineH);
    overflow: hidden;
  }
  .row{
    display: grid;
    grid-template-columns: 1fr 8px var(--sidebarW);
    overflow: hidden;
    min-height: 0;
  }
  #canvasWrap{ min-width:0; min-height:0; }
  #right{ min-width: 240px; overflow:auto; }
  .splitterV{
    cursor: col-resize;
    background: rgba(255,255,255,0.06);
    border-left: 1px solid rgba(255,255,255,0.08);
    border-right: 1px solid rgba(255,255,255,0.08);
  }
  .splitterV:hover{ background: rgba(255,255,255,0.10); }
  .splitterH{
    cursor: row-resize;
    background: rgba(255,255,255,0.06);
    border-top: 1px solid rgba(255,255,255,0.08);
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }
  .splitterH:hover{ background: rgba(255,255,255,0.10); }

  /* Timeline bar should never clip its contents */
  #timelineBar{
    height: var(--timelineH);
    min-height: 140px;
    overflow: hidden;
    display:flex;
    flex-direction:column;
  }
  #timelineCanvas{ flex: 1 1 auto; min-height: 0; }
  #timelineHint{ padding-bottom: 8px; }
</style>
</head>
<body>
<header class="toolbar">
  <input id="file" type="file" accept=".json" style="display:none" />
  <button id="btnFile" class="iconBtn" title="Open JSON">ðŸ“„</button>
  <button id="btnPlay" class="iconBtn" title="Play/Pause" disabled>â–¶</button>
  <div class="chip">
    <span class="muted">Speed</span>
    <select id="speedSelect" title="Playback speed">
      <option value="0.25">0.25Ã—</option>
      <option value="0.5">0.5Ã—</option>
      <option value="1" selected>1Ã—</option>
      <option value="2">2Ã—</option>
      <option value="4">4Ã—</option>
    </select>
  </div>
  <button id="btnFit" class="iconBtn" title="Fit to path" disabled>â¤¢</button>

  <div class="chip">
    <span class="muted">Field</span>
    <select id="fieldSelect" title="Field image">
      <option value="">No field image</option>
    </select>
  </div>

  <span class="grow muted" id="status">Drop a viewer JSON file.</span>
</header>

<div class="app">
  <div class="row">
    <div id="canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div id="vSplit" class="splitterV" title="Drag to resize"></div>

    <div id="right">
      <div class="section">
        <div class="drop muted">
          Tip: drag & drop a <code>*-viewer.json</code> file anywhere on the page.
        </div>
      </div>

      <div class="section">
        <details open id="secGeneral">
          <summary>
            <span>Config</span>
            <span class="pill" id="fmt">no file</span>
          </summary>
          <div class="detailsBody">
            <div style="font-weight:800" id="runName">â€”</div>
            <div class="muted" id="runMeta">â€”</div>

            <div style="margin-top:12px" class="grid2">
              <div>
                <label>Units (interpret input poses as)</label>
                <select id="unitsSelect">
                  <option value="in">inches</option>
                  <option value="cm">centimeters</option>
                  <option value="ft">foot</option>
                  <option value="tiles">tiles (24 in)</option>
                </select>
                <div class="muted" style="margin-top:6px">
                  Rendering uses inches internally.
                </div>
              </div>
              <div>
                <label>Robot size (inches on field)</label>
                <div class="grid2">
                  <input id="robotW" type="number" step="0.5" value="12" />
                  <input id="robotH" type="number" step="0.5" value="12" />
                </div>
                <div class="muted" style="margin-top:6px">width / height</div>
              </div>
            </div>

            <div style="margin-top:12px" class="grid3">
              <div>
                <label>X Offset</label>
                <input id="offX" type="number" step="0.1" value="0" />
              </div>
              <div>
                <label>Y Offset</label>
                <input id="offY" type="number" step="0.1" value="0" />
              </div>
              <div>
                <label>Theta Offset (deg)</label>
                <input id="offTheta" type="number" step="1" value="0" />
              </div>
            </div>
            <div class="muted" style="margin-top:8px">
              Offsets move the whole path relative to the field. (No auto-fit on offset changes.)
            </div>

            <div class="divider" style="margin:14px 0;"></div>
            <div style="font-weight:800; margin-bottom:6px">Stats</div>
            
            <div class="grid2" style="margin-bottom:10px">
              <div>
                <label>Min speed (normalize)</label>
                <input id="minSpeed" type="number" step="1" value="0" />
              </div>
              <div>
                <label>Max speed (normalize)</label>
                <input id="maxSpeed" type="number" step="1" value="127" />
              </div>
            </div>
            <div class="kvs" id="stats"></div>
          
</div>
        </details>
      </div>

      <div class="section">
        <details open id="secWatches">
          <summary>
            <span>Watches</span>
            <span class="pill" id="watchCount">â€”</span>
          </summary>
          <div class="detailsBody">
            <div class="rowline" style="margin-bottom:8px">
              <span class="muted">Sort</span>
              <select id="watchSort" style="margin-left:auto">
                <option value="level">level</option>
                <option value="time" selected>time</option>
                <option value="-time">-time</option>
                <option value="value">value</option>
              </select>
            </div>

            <div id="watchList"></div>
            <div class="muted" style="margin-top:10px">
              Click a watch to highlight it on the field and on the timeline.
            </div>
          </div>
        </details>
      </div>

      
    </div>
  </div>

  <div id="hSplit" class="splitterH" title="Drag to resize timeline"></div>

  <!-- Bottom timeline bar -->
  <div id="timelineBar">
    <div id="timelineTop">
      <span class="pill" id="timePill">Time: â€”</span>
      <span class="pill" id="pointPill">Point: â€”/â€”</span>
      <span class="pill" id="posePill" style="flex:1 1 auto; min-width: 260px;">X: â€”  Y: â€”  Theta: â€”  Speed: â€”</span>
    </div>
    <canvas id="timelineCanvas"></canvas>
    <div id="timelineHint" class="muted">
      Hover: preview robot at time â€¢ Click: set time â€¢ Watch dots are clickable
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const timelineCanvas = document.getElementById('timelineCanvas');
  const tctx = timelineCanvas.getContext('2d');

  const statusEl = document.getElementById('status');
  const fileEl = document.getElementById('file');
  const btnPlay = document.getElementById('btnPlay');
  const btnFit = document.getElementById('btnFit');
  const btnFile = document.getElementById('btnFile');
  const speedSelect = document.getElementById('speedSelect');
  const watchSort = document.getElementById('watchSort');
  const vSplit = document.getElementById('vSplit');
  const hSplit = document.getElementById('hSplit');
  const timePill = document.getElementById('timePill');
  const pointPill = document.getElementById('pointPill');
  const posePill = document.getElementById('posePill');
  // poseLine removed (posePill used)
  const runName = document.getElementById('runName');
  const runMeta = document.getElementById('runMeta');
  const fmt = document.getElementById('fmt');
  const statsEl = document.getElementById('stats');
  const watchList = document.getElementById('watchList');
  const watchCount = document.getElementById('watchCount');
  const fieldSelect = document.getElementById('fieldSelect');
  

  const offXEl = document.getElementById('offX');
  const offYEl = document.getElementById('offY');
  const offThetaEl = document.getElementById('offTheta');
  const unitsSelect = document.getElementById('unitsSelect');
  const robotWEl = document.getElementById('robotW');
  const robotHEl = document.getElementById('robotH');
  const minSpeedEl = document.getElementById('minSpeed');
  const maxSpeedEl = document.getElementById('maxSpeed');

  // --- YOUR FIELD IMAGES ---
  const FIELD_IMAGES = [
    { key: "./assets/match_field_2025-2026_pushback.png", label: "Field: Match Field" },
    { key: "./assets/skills_field_2025-2026_pushback.png", label: "Field: Skills Field" },
  ];

  // Field bounds in INCHES (default view when no Fit)
  const FIELD_BOUNDS_IN = { minX: -72, maxX: 72, minY: -72, maxY: 72, pad: 30 };

  const WATCH_TOL_MS = 40;
  const HOVER_PIXEL_TOL = 14;

  let data = null;
  let rawPoses = [];
    recomputeNormalizedSpeeds();
    // as loaded, in file units
  let watches = [];     // normalized watches
  let watchMarkers = []; // {watch, t, poseInches, ok:boolean, dt:number|null}
  let selectedWatch = null; // { marker }
  let selectedIndex = 0;    // locked pose index for display (non-playing)
  let hoverPose = null;     // hover on field
  let playPose = null;      // for animation
  let hoverTimelineTime = null; // preview time on timeline (ms)
  let timelineHoverSavedIndex = null; // restore after hover
  let hoverWatch = null;
  let timelineHotWatch = null;

  // playback clock
  let playing = false;
  let raf = null;
  let playTimeMs = null;
  let lastWall = null;
  let playRate = 1;

  // world->screen
  let bounds = { ...FIELD_BOUNDS_IN };
  let scale = 1;
  let offsetXpx = 0;
  let offsetYpx = 0;

  // field image
  let fieldImg = null;

  // offsets: entered in selected units, stored as inches for rendering
  const offsetsIn = { x: 0, y: 0, theta: 0 };

  // units: input pose units -> inches factor
  let unitsToInFactor = 1;

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function normalizeDeg(d) { let x = d % 360; if (x < 0) x += 360; return x; }
  function angLerpDeg(a, b, t) {
    a = normalizeDeg(a); b = normalizeDeg(b);
    let diff = (b - a + 540) % 360 - 180;
    return normalizeDeg(a + diff * t);
  }
  function fmtNum(v, d=2) { if (typeof v !== "number" || !isFinite(v)) return "â€”"; return v.toFixed(d); }

  // ---- speed normalization (affects numbers) ----
  function normSpeed(raw, minV, maxV){
    if (typeof raw !== "number" || !isFinite(raw)) return 0;
    if (typeof minV !== "number" || !isFinite(minV)) minV = 0;
    if (typeof maxV !== "number" || !isFinite(maxV)) maxV = 1;
    if (maxV === minV) return 0;
    const v = (raw - minV) / (maxV - minV);
    return clamp(v, 0, 1);
  }

  function getMinMaxSpeed(){
    const minEl = document.getElementById('minSpeed');
    const maxEl = document.getElementById('maxSpeed');
    const minV = minEl ? Number(minEl.value) : 0;
    const maxV = maxEl ? Number(maxEl.value) : 1;
    return { minV, maxV, minEl, maxEl };
  }

  function recomputeNormalizedSpeeds(){
    if (!rawPoses || !rawPoses.length) return;
    const { minV, maxV } = getMinMaxSpeed();
    for (const p of rawPoses){
      if (!p) continue;
      if (typeof p.speed_raw === "undefined") p.speed_raw = p.speed;
      const raw = (typeof p.speed_raw === "number") ? p.speed_raw : p.speed;
      p.speed = normSpeed(raw, minV, maxV); // canonical speed is normalized
    }
  }
  function setStatus(msg) { statusEl.textContent = msg; }
  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (c) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c]));
  }

  function levelStyle(levelRaw) {
    const L = String(levelRaw || "INFO").toUpperCase();
    if (L.includes("ERROR") || L.includes("FATAL")) return { name:"ERROR", fill:"#ff4d4d", text:"#081018" };
    if (L.includes("WARN")) return { name:"WARN", fill:"#ffd44d", text:"#081018" };
    if (L.includes("DEBUG") || L.includes("TRACE")) return { name:"DEBUG", fill:"#9aa7bb", text:"#081018" };
    return { name:"INFO", fill:"#4dff88", text:"#081018" };
  }

  function loadFieldOptions() {
    fieldSelect.innerHTML = `<option value="">No field image</option>`;
    for (const f of FIELD_IMAGES) {
      const opt = document.createElement('option');
      opt.value = f.key;
      opt.textContent = f.label;
      fieldSelect.appendChild(opt);
    }
  }

  async function loadFieldImage(filename) {
    if (!filename) { fieldImg = null; draw(); return; }
    const img = new Image();
    img.onload = () => { fieldImg = img; draw(); };
    img.onerror = () => { fieldImg = null; setStatus(`Could not load field image: ${filename}`); draw(); };
    img.src = filename;
  }

  function setUnitsFactorFromSelect(value) {
    if (value === "cm") unitsToInFactor = 1 / 2.54;
    else if (value === "ft") unitsToInFactor = 12;
    else if (value === "tiles") unitsToInFactor = 24;
    else unitsToInFactor = 1;
  }

  function inferUnitsFromMeta(metaUnits) {
    const u = String(metaUnits || "").toLowerCase().trim();
    if (!u) return "in";
    if (u.includes("tile")) return "tiles";
    if (u.includes("cm") || u.includes("cent")) return "cm";
    if (u === "ft" || u.includes("foot") || u.includes("feet")) return "ft";
    if (u.includes("in")) return "in";
    return "in";
  }

  function updateOffsetsFromInputs() {
    const ux = Number(offXEl.value || 0);
    const uy = Number(offYEl.value || 0);
    const ut = Number(offThetaEl.value || 0);

    offsetsIn.x = ux * unitsToInFactor;
    offsetsIn.y = uy * unitsToInFactor;
    offsetsIn.theta = ut;

    recomputeWatchMarkers();
    draw();
    updatePoseReadout();
    drawTimeline();
  }

  function robotDimsInches() {
    const w = Number(robotWEl.value || 12);
    const h = Number(robotHEl.value || 12);
    return { w: Math.max(1, w), h: Math.max(1, h) };
  }

  function normalizeSpeedForHeat(speedAbs) {
    const minS = Number(minSpeedEl.value || 0);
    const maxS = Number(maxSpeedEl.value || 127);
    const s = clamp(speedAbs, 0, 100000);
    if (maxS <= minS) return 0;
    return clamp((s - minS) / (maxS - minS), 0, 1);
  }

  function heatColor(speed) {
    const sAbs = Math.abs(speed || 0);
    if (sAbs <= 3) return "rgba(90,0,0,0.92)";
    const t = normalizeSpeedForHeat(sAbs);
    const u = 1 - t; // u=0 green, u=1 red

    let r,g,b;
    if (u <= 0.33) {
      const a = u / 0.33;
      r = 40 + a*(255-40); g = 220; b = 80;
    } else if (u <= 0.66) {
      const a = (u-0.33)/0.33;
      r = 255; g = 220 - a*(140); b = 80 - a*(40);
    } else {
      const a = (u-0.66)/0.34;
      r = 255; g = 80 - a*(70); b = 40 - a*(30);
    }
    return `rgba(${Math.round(r)},${Math.round(g)},${Math.round(b)},0.88)`;
  }

  function poseToInches(p) {
    return {
      t: (typeof p.t === "number") ? p.t : null,
      x: (p.x ?? 0) * unitsToInFactor + offsetsIn.x,
      y: (p.y ?? 0) * unitsToInFactor + offsetsIn.y,
      theta: normalizeDeg((p.theta ?? 0) + offsetsIn.theta),
      l_vel: (typeof p.l_vel === "number") ? p.l_vel : null,
      r_vel: (typeof p.r_vel === "number") ? p.r_vel : null,
      speed: (typeof p.speed === "number") ? p.speed : null,
    };
  }

  function getPosesInches() { return rawPoses.map(poseToInches); }

  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    computeTransform();
    draw();
  }

  function resizeTimeline() {
    const dpr = window.devicePixelRatio || 1;
    const rect = timelineCanvas.getBoundingClientRect();
    timelineCanvas.width = Math.max(1, Math.floor(rect.width * dpr));
    timelineCanvas.height = Math.max(1, Math.floor(rect.height * dpr));
    tctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    drawTimeline();
  }

  function computeTransform() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const pad = bounds.pad;
    const worldW = (bounds.maxX - bounds.minX) || 1;
    const worldH = (bounds.maxY - bounds.minY) || 1;
    scale = Math.min((w - pad*2) / worldW, (h - pad*2) / worldH);
    offsetXpx = pad - bounds.minX * scale;
    offsetYpx = pad + bounds.maxY * scale;
  }

  function worldToScreen(xIn, yIn) {
    return { x: offsetXpx + xIn * scale, y: offsetYpx - yIn * scale };
  }

  function hitTestWatchAtClient(clientX, clientY) {
    if (!watchMarkers.length) return null;
    const rect = canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    // threshold in CSS pixels
    const tol = 10;
    let best = null;
    let bestD2 = tol*tol;
    for (const m of watchMarkers) {
      if (!m.pose) continue;
      const p = worldToScreen(m.pose.x, m.pose.y);
      const dx = p.x - x;
      const dy = p.y - y;
      const d2 = dx*dx + dy*dy;
      if (d2 <= bestD2) { bestD2 = d2; best = m; }
    }
    return best;
  }


  function fitToPoses() {
    const poses = getPosesInches();
    if (!poses.length) return;
    let minX = poses[0].x, maxX = poses[0].x;
    let minY = poses[0].y, maxY = poses[0].y;
    for (const p of poses) {
      minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
      minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
    }
    const margin = 6;
    bounds.minX = minX - margin; bounds.maxX = maxX + margin;
    bounds.minY = minY - margin; bounds.maxY = maxY + margin;
    bounds.pad = FIELD_BOUNDS_IN.pad;
    computeTransform();
    draw();
  }

  // ---- time indexing ----
  function findFloorIndexByTime(tMs) {
    const poses = rawPoses;
    if (!poses.length) return -1;
    let lo = 0, hi = poses.length - 1;
    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      const tm = poses[mid].t ?? -Infinity;
      if (tm <= tMs) lo = mid + 1;
      else hi = mid - 1;
    }
    return clamp(hi, 0, poses.length - 1);
  }

  function interpolatePoseAtTime(tMs) {
    if (!rawPoses.length) return null;
    const i = findFloorIndexByTime(tMs);
    const p0 = rawPoses[i];
    if (i >= rawPoses.length - 1) return poseToInches({ ...p0, t: p0.t });

    const p1 = rawPoses[i+1];
    const t0 = p0.t ?? tMs;
    const t1 = p1.t ?? t0;
    const denom = (t1 - t0) || 1;
    const a = clamp((tMs - t0) / denom, 0, 1);

    const x = (p0.x ?? 0) + ((p1.x ?? 0) - (p0.x ?? 0)) * a;
    const y = (p0.y ?? 0) + ((p1.y ?? 0) - (p0.y ?? 0)) * a;
    const theta = angLerpDeg(p0.theta ?? 0, p1.theta ?? 0, a);

    const l_vel = (p0.l_vel ?? 0) + ((p1.l_vel ?? 0) - (p0.l_vel ?? 0)) * a;
    const r_vel = (p0.r_vel ?? 0) + ((p1.r_vel ?? 0) - (p0.r_vel ?? 0)) * a;
    const speed = (p0.speed ?? 0) + ((p1.speed ?? 0) - (p0.speed ?? 0)) * a;

    return poseToInches({ t: tMs, x, y, theta, l_vel, r_vel, speed });
  }

  function nearestIndexWithinTol(tMs, tolMs) {
    if (!rawPoses.length) return null;
    const i0 = findFloorIndexByTime(tMs);
    const cands = [i0, Math.min(i0+1, rawPoses.length-1)];
    let best = null;
    for (const i of cands) {
      const tt = rawPoses[i].t;
      if (typeof tt !== "number") continue;
      const dt = Math.abs(tt - tMs);
      if (best === null || dt < best.dt) best = { idx: i, dt };
    }
    if (best && best.dt <= tolMs) return best;
    return null;
  }

  // ---- watches: normalize / robust parse ----
  function toNumMaybe(v) {
    if (typeof v === "number" && isFinite(v)) return v;
    if (typeof v === "string") {
      const n = Number(v.trim());
      if (isFinite(n)) return n;
    }
    return null;
  }

  function normalizeWatches(arr) {
    const out = [];
    if (!Array.isArray(arr)) return out;

    for (const w of arr) {
      if (!w || typeof w !== "object") continue;
      const tRaw = (w.t ?? w.timestamp ?? w.time ?? w.ms);
      const t = toNumMaybe(tRaw);
      if (t == null) continue;

      out.push({
        t,
        level: w.level ?? w.lvl ?? w.severity ?? "INFO",
        label: w.label ?? w.name ?? "",
        value: (w.value ?? w.val ?? w.message ?? ""),
      });
    }
    // stable sort
    out.sort((a,b) => a.t - b.t);
    return out;
  }

  function recomputeWatchMarkers() {
    watchMarkers = [];
    for (const w of watches) {
      const t = w.t;
      const near = nearestIndexWithinTol(t, WATCH_TOL_MS);
      if (near) {
        const p = rawPoses[near.idx];
        watchMarkers.push({ watch: w, t, ok: true, dt: near.dt, pose: poseToInches(p), idx: near.idx });
      } else {
        const ip = interpolatePoseAtTime(t);
        if (ip) watchMarkers.push({ watch: w, t, ok: false, dt: null, pose: ip, idx: null });
      }
    }
  }

  // ---- drawing ----
  function drawField() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "#0b0f14";
    ctx.fillRect(0, 0, w, h);

    if (!fieldImg) return;
    const p0 = worldToScreen(bounds.minX, bounds.minY);
    const p1 = worldToScreen(bounds.maxX, bounds.maxY);
    const left = Math.min(p0.x, p1.x);
    const top = Math.min(p0.y, p1.y);
    const right = Math.max(p0.x, p1.x);
    const bottom = Math.max(p0.y, p1.y);

    ctx.globalAlpha = 0.95;
    ctx.drawImage(fieldImg, left, top, right - left, bottom - top);
    ctx.globalAlpha = 1.0;
  }

  function drawAxes() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const o = worldToScreen(0, 0);
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0, o.y); ctx.lineTo(w, o.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(o.x, 0); ctx.lineTo(o.x, h); ctx.stroke();
  }

  function drawPath() {
    const poses = getPosesInches();
    if (poses.length < 2) return;
    for (let i = 1; i < poses.length; i++) {
      const a = poses[i-1], b = poses[i];
      const pa = worldToScreen(a.x, a.y);
      const pb = worldToScreen(b.x, b.y);
      const grad = ctx.createLinearGradient(pa.x, pa.y, pb.x, pb.y);
      grad.addColorStop(0, heatColor(a.speed ?? 0));
      grad.addColorStop(1, heatColor(b.speed ?? 0));
      ctx.strokeStyle = grad;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y);
      ctx.lineTo(pb.x, pb.y);
      ctx.stroke();
    }
  }

  function drawWatchDots() {
    if (!watchMarkers.length) return;

    for (const m of watchMarkers) {
      const { pose, watch } = m;
      if (!pose) continue;
      const st = levelStyle(watch.level);
      const p = worldToScreen(pose.x, pose.y);

      const isHover = (hoverWatch === m);
      const r = isHover ? 5.6 : 4.2;
      const fillA = isHover ? 0.40 : 0.25;

      ctx.save();
      ctx.fillStyle = st.fill.replace(")", `,${fillA})`).replace("rgb", "rgba");
      ctx.strokeStyle = "rgba(255,255,255,0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    if (selectedWatch?.marker?.pose) {
      const st = levelStyle(selectedWatch.marker.watch.level);
      const pose = selectedWatch.marker.pose;
      const p = worldToScreen(pose.x, pose.y);

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 9.0, 0, Math.PI*2);
      ctx.stroke();

      ctx.fillStyle = st.fill.replace(")", ",0.35)").replace("rgb", "rgba");
      ctx.beginPath();
      ctx.arc(p.x, p.y, 6.5, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawRobot(pose, alpha=1.0) {
    if (!pose) return;
    const { w: wIn, h: hIn } = robotDimsInches();
    const center = worldToScreen(pose.x, pose.y);
    const wPx = wIn * scale;
    const hPx = hIn * scale;
    const thetaDeg = (pose.theta ?? 0);
    const thetaRad = (thetaDeg) * Math.PI / 180;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(center.x, center.y);
    ctx.rotate(thetaRad);

    ctx.fillStyle = "rgba(255,255,255,0.14)";
    ctx.strokeStyle = "rgba(255,255,255,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(-wPx/2, -hPx/2, wPx, hPx);
    ctx.fill();
    ctx.stroke();

    // front edge indicator
    ctx.strokeStyle = "rgba(255,255,255,0.98)";
    ctx.beginPath();
    ctx.moveTo(wPx/2, -hPx/2);
    ctx.lineTo(wPx/2,  hPx/2);
    ctx.stroke();

    // heading arrow
    const arrowLen = Math.max(wPx, hPx) * 0.85;
    ctx.strokeStyle = "rgba(255,255,255,0.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(arrowLen/2, 0);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(arrowLen/2, 0);
    ctx.lineTo(arrowLen/2 - 8, -5);
    ctx.lineTo(arrowLen/2 - 8,  5);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.fill();

    ctx.restore();
  }

  function draw() {
    drawField();
    drawAxes();
    drawPath();
    drawWatchDots();

    // field hover preview (if not timeline hover)
    if (hoverPose && !playing && hoverTimelineTime == null) drawRobot(hoverPose, 0.85);

    // timeline hover preview wins (when not playing)
    if (!playing && hoverTimelineTime != null) {
      const p = interpolatePoseAtTime(hoverTimelineTime);
      if (p) drawRobot(p, 0.95);
    }

    // playing robot
    if (playing && playPose) drawRobot(playPose, 1.0);

    // locked robot when idle and not hovering timeline
    if (!playing && hoverTimelineTime == null) {
      const poses = getPosesInches();
      const p = poses[selectedIndex] || null;
      if (p) drawRobot(p, 1.0);
    }
  }

  // ---- bottom timeline drawing ----
  function timeRange() {
    const t0 = rawPoses[0]?.t;
    const tN = rawPoses[rawPoses.length-1]?.t;
    if (typeof t0 !== "number" || typeof tN !== "number" || tN <= t0) return null;
    return { t0, tN };
  }

  function timeToX(t) {
    const rect = timelineCanvas.getBoundingClientRect();
    const W = rect.width;
    const range = timeRange();
    if (!range) return 0;
    const a = (t - range.t0) / (range.tN - range.t0);
    return clamp(a, 0, 1) * W;
  }

  function xToTime(x) {
    const rect = timelineCanvas.getBoundingClientRect();
    const W = rect.width || 1;
    const range = timeRange();
    if (!range) return 0;
    const a = clamp(x / W, 0, 1);
    return range.t0 + a * (range.tN - range.t0);
  }

  function drawTimeline() {
    const rect = timelineCanvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;
    tctx.clearRect(0, 0, W, H);

    // bg
    tctx.fillStyle = "rgba(16,23,32,0.55)";
    tctx.fillRect(0, 0, W, H);

    if (!rawPoses.length) return;

    const range = timeRange();
    if (!range) return;

    // grid lines
    tctx.strokeStyle = "rgba(255,255,255,0.08)";
    tctx.lineWidth = 1;
    const major = 10;
    for (let i=0; i<=major; i++) {
      const x = (W * i) / major;
      tctx.beginPath(); tctx.moveTo(x, 0); tctx.lineTo(x, H); tctx.stroke();
    }

    // speed trace
    // map speed to Y (higher speed higher up)
    const maxS = Math.max(1, Number(maxSpeedEl.value || 127));
    const minS = Math.max(0, Number(minSpeedEl.value || 0));
    const denom = Math.max(1, maxS - minS);

    tctx.lineWidth = 2;
    for (let i=1; i<rawPoses.length; i++) {
      const a = rawPoses[i-1], b = rawPoses[i];
      if (typeof a.t !== "number" || typeof b.t !== "number") continue;

      const xa = timeToX(a.t);
      const xb = timeToX(b.t);

      const sa = Math.abs(a.speed ?? 0);
      const sb = Math.abs(b.speed ?? 0);

      const ya = H - 6 - ((clamp((sa - minS)/denom, 0, 1)) * (H - 12));
      const yb = H - 6 - ((clamp((sb - minS)/denom, 0, 1)) * (H - 12));

      const grad = tctx.createLinearGradient(xa, ya, xb, yb);
      grad.addColorStop(0, heatColor(sa));
      grad.addColorStop(1, heatColor(sb));

      tctx.strokeStyle = grad;
      tctx.beginPath();
      tctx.moveTo(xa, ya);
      tctx.lineTo(xb, yb);
      tctx.stroke();
    }

    // watch dots on timeline
    for (const m of watchMarkers) {
      const st = levelStyle(m.watch.level);
      const x = timeToX(m.t);
      const y = 10; // top row
      tctx.save();
      tctx.fillStyle = st.fill.replace(")", ",0.25)").replace("rgb", "rgba");
      tctx.strokeStyle = "rgba(255,255,255,0.95)";
      tctx.lineWidth = 2;
      tctx.beginPath();
      tctx.arc(x, y, 4.2, 0, Math.PI*2);
      tctx.fill();
      tctx.stroke();
      tctx.restore();
    }

    // selection marker
    if (rawPoses[selectedIndex]?.t != null) {
      const x = timeToX(rawPoses[selectedIndex].t);
      tctx.strokeStyle = "rgba(255,255,255,0.95)";
      tctx.lineWidth = 2;
      tctx.beginPath();
      tctx.moveTo(x, 0);
      tctx.lineTo(x, H);
      tctx.stroke();
    }

    // hovered marker
    if (hoverTimelineTime != null) {
      const x = timeToX(hoverTimelineTime);
      tctx.strokeStyle = "rgba(255,255,255,0.5)";
      tctx.lineWidth = 1.5;
      tctx.beginPath();
      tctx.moveTo(x, 0);
      tctx.lineTo(x, H);
      tctx.stroke();
    }

    // selected watch marker emphasis
    if (selectedWatch?.marker?.t != null) {
      const x = timeToX(selectedWatch.marker.t);
      const y = 10;
      tctx.save();
      tctx.strokeStyle = "rgba(255,255,255,0.95)";
      tctx.lineWidth = 2;
      tctx.beginPath();
      tctx.arc(x, y, 9.0, 0, Math.PI*2);
      tctx.stroke();
      tctx.restore();
    }
  }

  function timelinePickWatchDot(mx, my) {
    // returns marker if within radius of dot (timeline coords)
    const rect = timelineCanvas.getBoundingClientRect();
    const x = mx, y = my;
    const r = 8;
    // dots at y=10
    for (const m of watchMarkers) {
      const dx = x - timeToX(m.t);
      const dy = y - 10;
      if ((dx*dx + dy*dy) <= r*r) return m;
    }
    return null;
  }

  // ---- hover on field path ----
  function updateHoverFromMouse(clientX, clientY) {
    if (!rawPoses.length) return;
    const rect = canvas.getBoundingClientRect();
    const mx = clientX - rect.left;
    const my = clientY - rect.top;
    const poses = getPosesInches();
    if (poses.length < 2) return;

    let best = { dist2: Infinity, i: -1, alpha: 0 };

    for (let i = 0; i < poses.length - 1; i++) {
      const a = poses[i], b = poses[i+1];
      const pa = worldToScreen(a.x, a.y);
      const pb = worldToScreen(b.x, b.y);

      const vx = pb.x - pa.x, vy = pb.y - pa.y;
      const wx = mx - pa.x, wy = my - pa.y;
      const vv = vx*vx + vy*vy || 1;
      let alpha = (wx*vx + wy*vy) / vv;
      alpha = clamp(alpha, 0, 1);

      const px = pa.x + alpha*vx;
      const py = pa.y + alpha*vy;
      const dx = mx - px, dy = my - py;
      const d2 = dx*dx + dy*dy;

      if (d2 < best.dist2) best = { dist2: d2, i, alpha };
    }

    const dist = Math.sqrt(best.dist2);
    if (dist > HOVER_PIXEL_TOL) {
      if (hoverPose) { hoverPose = null; updatePoseReadout(); draw(); }
      return;
    }

    const i0 = best.i, i1 = best.i + 1;
    const p0 = poses[i0], p1 = poses[i1];
    const a = best.alpha;

    hoverPose = {
      t: null,
      x: p0.x + (p1.x - p0.x) * a,
      y: p0.y + (p1.y - p0.y) * a,
      theta: angLerpDeg(p0.theta ?? 0, p1.theta ?? 0, a),
      l_vel: (p0.l_vel ?? 0) + ((p1.l_vel ?? 0) - (p0.l_vel ?? 0)) * a,
      r_vel: (p0.r_vel ?? 0) + ((p1.r_vel ?? 0) - (p0.r_vel ?? 0)) * a,
      speed: (p0.speed ?? 0) + ((p1.speed ?? 0) - (p0.speed ?? 0)) * a,
    };

    updatePoseReadout();
    draw();
  }

  // ---- watch list ----
  function renderWatchList() {
    watchList.innerHTML = "";
    watchCount.textContent = `${watchMarkers.length}`;

    const mode = watchSort ? watchSort.value : "time";
    const items = watchMarkers.slice();

    const valKey = (v) => {
      if (v == null) return { t: 2, n: 0, s: "" };
      if (typeof v === "boolean") return { t: 0, n: v ? 1 : 0, s: String(v) };
      if (typeof v === "number") return { t: 1, n: v, s: "" };
      return { t: 0, n: 0, s: String(v) };
    };

    items.sort((a,b) => {
      const wa = a.watch || {};
      const wb = b.watch || {};
      if (mode === "level") return String(wa.level||"").localeCompare(String(wb.level||""));
      if (mode === "time") return (a.t ?? 0) - (b.t ?? 0);
      if (mode === "-time") return (b.t ?? 0) - (a.t ?? 0);
      if (mode === "value") {
        const ka = valKey(wa.value);
        const kb = valKey(wb.value);
        if (ka.t !== kb.t) return ka.t - kb.t;              // bool/string first, then numbers, then nulls
        if (ka.t === 1) return (ka.n - kb.n);               // numeric
        return ka.s.localeCompare(kb.s);                    // string/bool
      }
      return 0;
    });

    for (let i=0; i<items.length; i++) {
      const m = items[i];
      const w = m.watch;
      const st = levelStyle(w.level);
      const label = w.label || "";
      const value = w.value ?? "";
      const t = m.t;

      const div = document.createElement("div");
      div.className = "watchItem";
      div.dataset.t = String(t);

      div.innerHTML = `
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap">
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <span class="pill level" style="background:${st.fill};color:${st.text}">${escapeHtml(st.name)}</span>
            <span style="font-weight:850;word-break:break-word">${escapeHtml(label)}</span>
          </div>
          <div class="muted">${t != null ? (t + "ms") : ""}</div>
        </div>
        <div class="bigValue">${escapeHtml(String(value))}</div>
      `;

      div.onclick = () => selectWatchMarker(m, true);
      watchList.appendChild(div);
    }

    if (selectedWatch?.marker?.t != null) highlightWatchInList(selectedWatch.marker.t);
  }

  function highlightWatchInList(tMs) {
    const items = watchList.querySelectorAll(".watchItem");
    items.forEach(el => el.classList.remove("selected"));
    const el = watchList.querySelector(`.watchItem[data-t="${CSS.escape(String(tMs))}"]`);
    if (el) {
      el.classList.add("selected");
      // scroll into view
      el.scrollIntoView({ block: "nearest" });
    }
  }

  function selectWatchMarker(marker, fromUserClick=false) {
    selectedWatch = { marker };
    timelineHotWatch = marker;

    // lock time near this watch
    const near = nearestIndexWithinTol(marker.t, WATCH_TOL_MS);
    if (near) {
      selectedIndex = near.idx;
      setStatus(`Watch @${marker.t}ms mapped to pose @${rawPoses[near.idx].t}ms (Î”=${near.dt}ms).`);
    } else {
      // lock to closest floor time
      selectedIndex = findFloorIndexByTime(marker.t);
      setStatus(`Watch @${marker.t}ms shown via interpolation (no pose within Â±${WATCH_TOL_MS}ms).`);
    }

    pause();
    hoverPose = null;
    hoverTimelineTime = null;
    timelineHoverSavedIndex = null;

    highlightWatchInList(marker.t);
    updatePoseReadout();
    draw();
    drawTimeline();
  }

  // ---- playback ----
  function pause() {
    playing = false;
    btnPlay.textContent = "â–¶";
    if (raf) cancelAnimationFrame(raf);
    raf = null;
    playPose = null;
    lastWall = null;
  }

  function play() {
    if (!rawPoses.length) return;
    const tStart = rawPoses[selectedIndex]?.t;
    playTimeMs = (typeof tStart === "number") ? tStart : (rawPoses[0]?.t ?? 0);
    playing = true;
    btnPlay.textContent = "â¸";
    lastWall = performance.now();

    const tick = (now) => {
      if (!playing) return;
      const dtWall = now - lastWall;
      lastWall = now;
      playTimeMs += dtWall * playRate;

      const tMin = rawPoses[0]?.t ?? 0;
      const tMax = rawPoses[rawPoses.length - 1]?.t ?? tMin;

      if (playTimeMs >= tMax) {
        playTimeMs = tMax;
        playPose = interpolatePoseAtTime(playTimeMs);
        selectedIndex = rawPoses.length - 1;
        updatePoseReadout();
        draw();
        drawTimeline();
        pause();
        return;
      }

      playPose = interpolatePoseAtTime(playTimeMs);
      selectedIndex = findFloorIndexByTime(playTimeMs);

      selectedWatch = null;
      updatePoseReadout();
      draw();
      drawTimeline();
      raf = requestAnimationFrame(tick);
    };

    raf = requestAnimationFrame(tick);
  }

  // ---- readout ----
  function updatePoseReadout() {
    if (!data || !rawPoses.length) {
      if (timePill) timePill.textContent = "Time: â€”";
      if (pointPill) pointPill.textContent = "Point: â€”/â€”";
      if (posePill) posePill.textContent = "X: â€”  Y: â€”  Theta: â€”  Speed: â€”";
      return;
    }

    // choose a pose to display (priority: playing > hover timeline > selected index)
    let t = null;
    let idx = selectedIndex ?? 0;
    let p = null;

    if (playing) {
      t = playTimeMs;
      p = playPose || interpolatePoseAtTime(playTimeMs);
      idx = findFloorIndexByTime(playTimeMs);
    } else if (hoverTimelineTime != null) {
      t = hoverTimelineTime;
      p = interpolatePoseAtTime(hoverTimelineTime);
      idx = findFloorIndexByTime(hoverTimelineTime);
    } else {
      const rp = rawPoses[idx];
      t = rp?.t ?? null;
      p = rp ? applyOffsetsToPose(rp) : null;
    }

    const total = rawPoses.length;
    if (timePill) timePill.textContent = (t == null) ? "Time: â€”" : `Time: ${Math.round(t)}ms`;
    if (pointPill) pointPill.textContent = `Point: ${Math.max(1, idx+1)}/${total}`;
    if (posePill) {
      if (!p) posePill.textContent = "X: â€”  Y: â€”  Theta: â€”  Speed: â€”";
      else posePill.textContent = `X: ${fmtNum(p.x,1)}  Y: ${fmtNum(p.y,1)}  Theta: ${fmtNum(p.theta,1)}Â°  Speed: ${fmtNum(p.speed,3)}`;
    }
  }

  // ---- data loading ----
  function setData(obj) {
    data = obj;
    if (!obj || !Array.isArray(obj.poses)) {
      setStatus("Invalid viewer JSON: missing poses[]");
      return;
    }

    rawPoses = obj.poses
      .filter(p => p && typeof p.x === "number" && typeof p.y === "number")
      .map(p => ({
        t: (typeof p.t === "number") ? p.t : (toNumMaybe(p.t) ?? null),
        x: p.x, y: p.y,
        theta: (typeof p.theta === "number") ? p.theta : (toNumMaybe(p.theta) ?? 0),
        l_vel: (typeof p.l_vel === "number") ? p.l_vel : (toNumMaybe(p.l_vel) ?? null),
        r_vel: (typeof p.r_vel === "number") ? p.r_vel : (toNumMaybe(p.r_vel) ?? null),
        speed: (typeof p.speed === "number") ? p.speed : (toNumMaybe(p.speed) ?? null),
      }))
      .sort((a,b) => (a.t ?? 0) - (b.t ?? 0));

    watches = normalizeWatches(obj.watches);

    const inferred = inferUnitsFromMeta(obj?.meta?.units);
    unitsSelect.value = inferred;
    setUnitsFactorFromSelect(inferred);

    const rw = obj?.meta?.robot?.width;
    const rh = obj?.meta?.robot?.height;
    robotWEl.value = (typeof rw === "number" && isFinite(rw)) ? String(rw) : "12";
    robotHEl.value = (typeof rh === "number" && isFinite(rh)) ? String(rh) : "12";

    offXEl.value = "0";
    offYEl.value = "0";
    offThetaEl.value = "0";
    updateOffsetsFromInputs();

    fmt.textContent = `${obj.format || "unknown"} v${obj.version ?? "?"}`;
    runName.textContent = obj?.meta?.run_name || "â€”";
    runMeta.textContent = `${obj?.meta?.coord_system || "â€”"} â€¢ log_hz=${obj?.meta?.log_hz ?? "â€”"} â€¢ meta.units=${obj?.meta?.units ?? "â€”"}`;

    selectedWatch = null;
    selectedIndex = 0;
    hoverPose = null;
    hoverTimelineTime = null;
    timelineHoverSavedIndex = null;
    pause();

    recomputeWatchMarkers();
    renderWatchList();

    const th = obj.thinning || {};
    const t0 = rawPoses[0]?.t;
    const tN = rawPoses[rawPoses.length-1]?.t;
    const rows = [
      ["poses(file)", rawPoses.length],
      ["watches(file)", watches.length],
      ["watches(mapped)", watchMarkers.length],
      ["file raw est", th.raw ?? "â€”"],
      ["file kept", th.kept ?? "â€”"],
      ["file removed", th.removed ?? "â€”"],
      ["viewer_thin_ms", th.viewer_thin_ms ?? "â€”"],
      ["t range", (typeof t0==="number" && typeof tN==="number") ? `${t0}â€¦${tN} ms` : "â€”"],
    ];
    statsEl.innerHTML = "";
    for (const [k, v] of rows) {
      const a = document.createElement("div"); a.textContent = k;
      const b = document.createElement("div"); b.textContent = String(v);
      statsEl.appendChild(a); statsEl.appendChild(b);
    }
bounds = { ...FIELD_BOUNDS_IN };
    computeTransform();

    setStatus(`Loaded ${rawPoses.length} poses, ${watches.length} watches.`);
    updatePoseReadout();
    draw();
    drawTimeline();

    btnPlay.disabled = rawPoses.length < 2;
    btnFit.disabled = rawPoses.length < 2;
    fieldSelect.disabled = false;
  }

  async function handleFile(file) {
    try {
      const text = await file.text();
      const obj = JSON.parse(text);
      setData(obj);
    } catch (e) {
      console.error(e);
      setStatus(`Failed to load: ${e?.message || e}`);
    }
  }

  // ---- timeline interactions (hover preview + click lock + watch clicks) ----
  function timelineMousePos(e) {
    const rect = timelineCanvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  timelineCanvas.addEventListener("mousemove", (e) => {
    if (!data || playing || !rawPoses.length) return;

    const { x, y } = timelineMousePos(e);

    // if hovering a watch dot, we could change cursor
    const hit = timelinePickWatchDot(x, y);
    timelineCanvas.style.cursor = hit ? "pointer" : "crosshair";

    if (timelineHoverSavedIndex == null) timelineHoverSavedIndex = selectedIndex;

    hoverTimelineTime = xToTime(x);
    updatePoseReadout();
    draw();
    drawTimeline();
  });

  timelineCanvas.addEventListener("mouseleave", () => {
    if (!data || playing) return;
    hoverTimelineTime = null;
    timelineCanvas.style.cursor = "default";
    if (timelineHoverSavedIndex != null) {
      // restore robot to where it was before hover
      selectedIndex = timelineHoverSavedIndex;
      timelineHoverSavedIndex = null;
    }
    updatePoseReadout();
    draw();
    drawTimeline();
  });

  timelineCanvas.addEventListener("mousedown", (e) => {
    if (!data || playing || !rawPoses.length) return;
    const { x, y } = timelineMousePos(e);

    // prefer watch-dot click if hit
    const hit = timelinePickWatchDot(x, y);
    if (hit) {
      selectWatchMarker(hit, true);
      return;
    }

    // lock time at cursor
    const t = xToTime(x);
    selectedIndex = findFloorIndexByTime(t);
    hoverTimelineTime = null;
    timelineHoverSavedIndex = null;
    selectedWatch = null;

    updatePoseReadout();
    draw();
    drawTimeline();
  });

    // ---- field hover ----
  canvas.addEventListener('mousemove', (e) => {
    if (playing || hoverTimelineTime != null) return;

    const hw = hitTestWatchAtClient(e.clientX, e.clientY);
    if (hw) {
      hoverWatch = hw;
      canvas.style.cursor = "pointer";
      // don't override hoverPose when directly over a watch
      updatePoseReadout();
      draw();
      return;
    } else {
      if (hoverWatch) { hoverWatch = null; draw(); }
      canvas.style.cursor = "";
    }

    updateHoverFromMouse(e.clientX, e.clientY);
  });
  canvas.addEventListener('mouseleave', () => {
    hoverWatch = null;
    canvas.style.cursor = "";
    if (hoverPose) { hoverPose = null; updatePoseReadout(); draw(); }
  });
  canvas.addEventListener('click', (e) => {
    if (playing) return;
    const hw = hitTestWatchAtClient(e.clientX, e.clientY);
    if (hw) {
      selectWatchMarker(hw, true);
      updatePoseReadout();
      draw();
      drawTimeline();
    }
  });


  // ---- controls ----
  window.addEventListener('resize', () => { resizeCanvas(); resizeTimeline(); });

  // ---- splitters (sidebar + timeline) ----
  (function setupSplitters(){
    const root = document.documentElement;

    // vertical: sidebar width
    let draggingV = false;
    let startX = 0;
    let startW = 0;

    const getSidebarW = () => {
      const v = getComputedStyle(root).getPropertyValue('--sidebarW').trim();
      const n = parseFloat(v);
      return isFinite(n) ? n : 360;
    };
    const setSidebarW = (px) => root.style.setProperty('--sidebarW', `${px}px`);

    if (vSplit) {
      vSplit.addEventListener('mousedown', (e) => {
        draggingV = true;
        startX = e.clientX;
        startW = getSidebarW();
        document.body.style.cursor = 'col-resize';
        e.preventDefault();
      });
    }

    // horizontal: timeline height
    let draggingH = false;
    let startY = 0;
    let startH = 0;

    const getTimelineH = () => {
      const v = getComputedStyle(root).getPropertyValue('--timelineH').trim();
      const n = parseFloat(v);
      return isFinite(n) ? n : 260;
    };
    const setTimelineH = (px) => root.style.setProperty('--timelineH', `${px}px`);

    if (hSplit) {
      hSplit.addEventListener('mousedown', (e) => {
        draggingH = true;
        startY = e.clientY;
        startH = getTimelineH();
        document.body.style.cursor = 'row-resize';
        e.preventDefault();
      });
    }

    window.addEventListener('mousemove', (e) => {
      if (draggingV) {
        const dx = e.clientX - startX;
        const w = window.innerWidth;
        const next = clamp(startW - dx, 240, Math.max(260, w - 240));
        setSidebarW(next);
        resizeCanvas(); resizeTimeline();
      }
      if (draggingH) {
        const dy = e.clientY - startY;
        const h = window.innerHeight;
        const next = clamp(startH - dy, 140, Math.max(160, Math.floor(h * 0.70)));
        setTimelineH(next);
        resizeTimeline();
        resizeCanvas();
      }
    });

    window.addEventListener('mouseup', () => {
      if (draggingV || draggingH) {
        draggingV = false;
        draggingH = false;
        document.body.style.cursor = '';
        resizeCanvas(); resizeTimeline();
      }
    });
  })();

    btnFile.addEventListener('click', () => fileEl.click());
  speedSelect.addEventListener('change', () => { playRate = Number(speedSelect.value)||1; });
  if (watchSort) watchSort.addEventListener('change', () => { renderWatchList(); draw(); drawTimeline(); });
fileEl.addEventListener('change', (e) => {
    const file = e.target.files?.[0];
    if (file) handleFile(file);
  });

  document.addEventListener('dragover', (e) => { e.preventDefault(); });
  document.addEventListener('drop', (e) => {
    e.preventDefault();
    const file = e.dataTransfer?.files?.[0];
    if (file) handleFile(file);
  });

  btnPlay.addEventListener('click', () => {
    if (!data) return;
    if (playing) { pause(); updatePoseReadout(); draw(); drawTimeline(); }
    else play();
  });

  btnFit.addEventListener('click', () => {
    fitToPoses();
  });

  fieldSelect.addEventListener('change', (e) => {
    loadFieldImage(e.target.value);
  });

  unitsSelect.addEventListener('change', (e) => {
    setUnitsFactorFromSelect(e.target.value);
    updateOffsetsFromInputs();
    drawTimeline();
  });

  robotWEl.addEventListener('input', () => { draw(); });
  robotHEl.addEventListener('input', () => { draw(); });

  minSpeedEl.addEventListener('input', () => { draw(); drawTimeline(); });
  maxSpeedEl.addEventListener('input', () => { draw(); drawTimeline(); });

  offXEl.addEventListener('input', updateOffsetsFromInputs);
  offYEl.addEventListener('input', updateOffsetsFromInputs);
  offThetaEl.addEventListener('input', updateOffsetsFromInputs);

  document.addEventListener('keydown', (e) => {
    if (!data) return;
    if (e.code === "Space") { e.preventDefault(); playing ? (pause(), updatePoseReadout(), draw(), drawTimeline()) : play(); }
    if (e.code === "ArrowLeft") { e.preventDefault(); pause(); selectedWatch=null; selectedIndex = Math.max(0, selectedIndex-1); updatePoseReadout(); draw(); drawTimeline(); }
    if (e.code === "ArrowRight") { e.preventDefault(); pause(); selectedWatch=null; selectedIndex = Math.min(rawPoses.length-1, selectedIndex+1); updatePoseReadout(); draw(); drawTimeline(); }
  });

  // ---- init ----
  loadFieldOptions();
  resizeCanvas();
  resizeTimeline();
})();

  // min/max speed: recompute canonical normalized speeds, then redraw
  (function initMinMaxSpeed(){
    const { minEl, maxEl } = getMinMaxSpeed();
    const onMM = () => { recomputeNormalizedSpeeds(); draw(); drawTimeline(); updatePoseReadout(); };
    if (minEl) minEl.addEventListener('input', onMM);
    if (maxEl) maxEl.addEventListener('input', onMM);
  })();

</script>
</body>
</html>